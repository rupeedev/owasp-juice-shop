name: Enhanced Pipeline with Security Scanning

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  # Stage 1: Lint (existing)
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm install --prefer-offline --no-audit

      - name: Run linter
        run: npm run lint
        continue-on-error: true

  # Stage 2a: SAST (Parallel)
  sast:
    name: SAST - CodeQL Analysis
    runs-on: ubuntu-latest
    needs: lint
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: javascript
          config-file: ./.github/codeql/codeql-config.yml

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:javascript"
          output: sarif-results
          upload: false  # We'll upload manually to get artifact
        continue-on-error: true  # Warning mode for training

      - name: Generate Human-Readable CodeQL Report
        if: always()
        run: |
          echo "üìä Converting SARIF results to human-readable format..."
          python3 .github/scripts/parse-sarif.py sarif-results codeql-readable-report.txt

          echo ""
          echo "‚úÖ Readable report generated!"
          echo ""
          echo "Preview of report:"
          echo "=================="
          head -50 codeql-readable-report.txt
          echo "=================="
          echo "(Full report available in artifact download)"
        continue-on-error: true

      - name: Upload SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: sarif-results
        continue-on-error: true

      - name: Upload CodeQL Results as Artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: codeql-results
          path: |
            sarif-results/**/*.sarif
            codeql-readable-report.txt
          retention-days: 30

      - name: SAST scan complete
        run: |
          echo "‚úÖ CodeQL SAST analysis completed"
          echo "üìä Results available in:"
          echo "   1. GitHub Security tab > Code scanning alerts"
          echo "   2. Download 'codeql-results' artifact from this workflow run"
          echo "   3. Human-readable report: codeql-readable-report.txt (in artifact)"
          echo ""
          echo "üìÑ Report formats:"
          echo "   ‚Ä¢ SARIF files: For tool integration and GitHub Security"
          echo "   ‚Ä¢ Readable report: For quick review and training purposes"
          echo ""
          echo "‚ö†Ô∏è  Note: Juice Shop is intentionally vulnerable - findings are expected"

  # Stage 2b: Secret Detection (Parallel)
  secret-detection:
    name: Secret Detection - TruffleHog
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for secret scanning

      - name: Run TruffleHog Secret Scan
        run: |
          echo "üîê Running TruffleHog secret scan..."
          echo "Scanning entire git history for leaked credentials..."

          # Pull Docker image first (to separate pull logs from results)
          docker pull trufflesecurity/trufflehog:latest > /dev/null 2>&1

          # Run TruffleHog with Docker (JSON output to file)
          docker run --rm -v $(pwd):/repo \
            trufflesecurity/trufflehog:latest \
            git file:///repo --only-verified --json > trufflehog-report.json 2>&1 || echo "‚ö†Ô∏è  Secrets found (warning mode)"

          # Display summary (parse NDJSON properly)
          if [ -s trufflehog-report.json ]; then
            echo ""
            echo "üìä TruffleHog Scan Results:"

            # Extract summary from last line (finished scanning message)
            SUMMARY=$(grep -o '"verified_secrets":[0-9]*' trufflehog-report.json | tail -1 | cut -d: -f2)
            UNVERIFIED=$(grep -o '"unverified_secrets":[0-9]*' trufflehog-report.json | tail -1 | cut -d: -f2)

            if [ -n "$SUMMARY" ]; then
              echo "   Verified secrets: ${SUMMARY:-0}"
              echo "   Unverified secrets: ${UNVERIFIED:-0}"

              if [ "${SUMMARY:-0}" -eq 0 ] && [ "${UNVERIFIED:-0}" -eq 0 ]; then
                echo "   ‚úÖ No secrets detected"
              else
                echo "   ‚ö†Ô∏è  Secrets found - review report for details"
              fi
            else
              echo "   Scan completed - check report for details"
            fi
          else
            echo "‚úÖ No output - scan may have found nothing"
          fi
        continue-on-error: true  # Warning mode for training

      - name: Generate Human-Readable TruffleHog Report
        if: always()
        run: |
          echo "üìä Converting TruffleHog results to human-readable format..."

          if [ -f trufflehog-report.json ]; then
            python3 .github/scripts/parse-trufflehog.py trufflehog-report.json trufflehog-readable-report.txt

            echo ""
            echo "‚úÖ Readable report generated!"
            echo ""
            echo "Preview of report:"
            echo "=================="
            head -60 trufflehog-readable-report.txt
            echo "=================="
            echo "(Full report available in artifact download)"
          else
            echo "‚ö†Ô∏è  No TruffleHog report found to parse"
          fi
        continue-on-error: true

      - name: Upload TruffleHog Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: secret-detection-report
          path: |
            trufflehog-report.json
            trufflehog-readable-report.txt
          retention-days: 30

  # Stage 2c: Unit Tests (Parallel)
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: |
          npm install --prefer-offline --no-audit
          cd frontend && npm install --prefer-offline --no-audit

      - name: Verify Karma configuration
        run: |
          echo "üìù Verifying test configuration files..."
          ls -la frontend/src/karma.conf.js || echo "‚ö†Ô∏è  Karma config missing"
          ls -la frontend/src/test.ts || echo "‚ö†Ô∏è  Test bootstrap missing"
          ls -la frontend/src/tsconfig.spec.json || echo "‚ö†Ô∏è  Test tsconfig missing"

      - name: Run backend tests only (frontend tests skipped in CI)
        run: |
          echo "üß™ Running backend unit tests..."
          npm run test:server || echo "‚ö†Ô∏è  Backend tests failed (continuing in training mode)"
        continue-on-error: true  # Warning mode for training

  # Stage 3: Security Scan (Advanced - runs after all Stage 2 jobs)
  # Stage 3a: npm Audit
  npm-audit:
    name: npm Audit
    runs-on: ubuntu-latest
    needs: [sast, secret-detection, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Run npm audit
        run: |
          echo "üì¶ Running npm audit..."
          npm audit --audit-level=moderate > npm-audit.txt 2>&1 || echo "‚ö†Ô∏è  Vulnerabilities found (warning mode)"
          cat npm-audit.txt
        continue-on-error: true

      - name: Upload npm Audit Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-npm-audit
          path: npm-audit.txt
          retention-days: 30

  # Stage 3b: RetireJS
  retirejs:
    name: RetireJS - Vulnerable JavaScript Libraries
    runs-on: ubuntu-latest
    needs: [sast, secret-detection, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install project dependencies
        run: |
          echo "üì¶ Installing project dependencies (required for RetireJS scanning)..."
          npm install --prefer-offline --no-audit
          echo "‚úÖ Dependencies installed"

      - name: Install RetireJS globally
        run: |
          echo "üìö Installing RetireJS scanner..."
          npm install -g retire
          retire --version
          echo "‚úÖ RetireJS installed"

      - name: Run RetireJS Scan (Multiple Formats)
        run: |
          echo "üîç Running RetireJS vulnerability scan..."
          echo "Scanning JavaScript libraries and Node.js modules for known vulnerabilities"
          echo ""

          # Create reports directory
          mkdir -p retirejs-reports

          # Run RetireJS with JSON output (for machine processing)
          echo "=== Generating JSON Report ===" | tee retirejs-reports/scan-output.txt
          retire --path . --outputformat json --exitwith 0 > retirejs-reports/retirejs-report.json 2>&1 || true

          # Run RetireJS with CycloneDX SBOM format (industry standard)
          echo "" | tee -a retirejs-reports/scan-output.txt
          echo "=== Generating CycloneDX SBOM Report ===" | tee -a retirejs-reports/scan-output.txt
          retire --path . --outputformat cyclonedx --exitwith 0 > retirejs-reports/retirejs-sbom.json 2>&1 || true

          # Run RetireJS with verbose text output (for human reading)
          echo "" | tee -a retirejs-reports/scan-output.txt
          echo "=== Detailed Vulnerability Scan ===" | tee -a retirejs-reports/scan-output.txt
          retire --path . --verbose --exitwith 0 2>&1 | tee -a retirejs-reports/scan-output.txt || true

          echo ""
          echo "‚úÖ RetireJS scan completed"
          echo "üìä Generated reports:"
          echo "   ‚Ä¢ retirejs-report.json (JSON format)"
          echo "   ‚Ä¢ retirejs-sbom.json (CycloneDX SBOM)"
          echo "   ‚Ä¢ scan-output.txt (Verbose text)"
        continue-on-error: true

      - name: Generate Human-Readable Report
        if: always()
        run: |
          echo "üìä Analyzing RetireJS results..."

          # Check if JSON report exists and has content
          if [ -f "retirejs-reports/retirejs-report.json" ]; then
            # Create Python script for parsing
            cat > parse_retire.py << 'PYEOF'
          import json
          import sys
          import os

          # Read RetireJS JSON report
          try:
              with open('retirejs-reports/retirejs-report.json', 'r') as f:
                  content = f.read().strip()

              if not content or content == '[]':
                  print("No vulnerabilities detected by RetireJS")
                  with open('retirejs-reports/retirejs-readable-report.txt', 'w') as out:
                      out.write("=" * 80 + "\n")
                      out.write("RETIREJS VULNERABILITY SCAN REPORT\n")
                      out.write("=" * 80 + "\n\n")
                      out.write("Scan Status: COMPLETED\n")
                      out.write("Vulnerabilities Found: 0\n\n")
                      out.write("No vulnerable JavaScript libraries detected\n\n")
                      out.write("Note: This scan checks for known vulnerabilities in:\n")
                      out.write("  - JavaScript libraries (client-side)\n")
                      out.write("  - Node.js modules (server-side)\n")
                      out.write("  - Bower components\n")
                      out.write("  - Third-party dependencies\n\n")
                      out.write("=" * 80 + "\n")
                  sys.exit(0)

              # Parse JSON data
              data = json.loads(content)

              # Generate readable report
              with open('retirejs-reports/retirejs-readable-report.txt', 'w') as out:
                  out.write("=" * 80 + "\n")
                  out.write("RETIREJS VULNERABILITY SCAN REPORT\n")
                  out.write("=" * 80 + "\n\n")

                  # Count vulnerabilities
                  total_vulns = 0
                  high_severity = 0
                  medium_severity = 0
                  low_severity = 0

                  if isinstance(data, list):
                      for finding in data:
                          results = finding.get('results', [])
                          for result in results:
                              vulns = result.get('vulnerabilities', [])
                              total_vulns += len(vulns)
                              for vuln in vulns:
                                  severity = vuln.get('severity', 'unknown').lower()
                                  if 'high' in severity or 'critical' in severity:
                                      high_severity += 1
                                  elif 'medium' in severity:
                                      medium_severity += 1
                                  else:
                                      low_severity += 1

                  out.write(f"Total Vulnerabilities: {total_vulns}\n")
                  out.write(f"  - High/Critical: {high_severity}\n")
                  out.write(f"  - Medium: {medium_severity}\n")
                  out.write(f"  - Low/Info: {low_severity}\n\n")
                  out.write("=" * 80 + "\n\n")

                  # Detailed findings
                  if isinstance(data, list) and data:
                      out.write("DETAILED FINDINGS:\n\n")

                      for idx, finding in enumerate(data, 1):
                          file_path = finding.get('file', 'Unknown')
                          results = finding.get('results', [])

                          out.write(f"[{idx}] File: {file_path}\n")
                          out.write("-" * 80 + "\n")

                          for result in results:
                              component = result.get('component', 'Unknown')
                              version = result.get('version', 'Unknown')
                              detection = result.get('detection', 'Unknown')

                              out.write(f"  Component: {component}\n")
                              out.write(f"  Version: {version}\n")
                              out.write(f"  Detection Method: {detection}\n")

                              vulns = result.get('vulnerabilities', [])
                              if vulns:
                                  out.write(f"  Vulnerabilities ({len(vulns)}):\n\n")

                                  for vuln_idx, vuln in enumerate(vulns, 1):
                                      severity = vuln.get('severity', 'Unknown')
                                      identifiers = vuln.get('identifiers', {})
                                      cve_list = identifiers.get('CVE', [])
                                      cve = cve_list[0] if cve_list else 'N/A'
                                      info_urls = vuln.get('info', [])

                                      out.write(f"    [{vuln_idx}] Severity: {severity}\n")
                                      out.write(f"        CVE: {cve}\n")
                                      if info_urls:
                                          out.write(f"        Info: {info_urls[0]}\n")
                                      out.write("\n")

                              out.write("\n")

                  out.write("=" * 80 + "\n")
                  out.write("SCAN COMPLETED\n")
                  out.write("=" * 80 + "\n")

              print("Human-readable report generated successfully")

          except json.JSONDecodeError as e:
              print(f"JSON parsing error: {e}")
              print("Generating minimal report...")
              with open('retirejs-reports/retirejs-readable-report.txt', 'w') as out:
                  out.write("RetireJS scan completed but JSON parsing failed\n")
                  out.write("Check retirejs-report.json and scan-output.txt for raw results\n")
          except Exception as e:
              print(f"Error generating report: {e}")
              with open('retirejs-reports/retirejs-readable-report.txt', 'w') as out:
                  out.write(f"Error generating readable report: {str(e)}\n")
          PYEOF

            # Run the Python script
            python3 parse_retire.py
            rm -f parse_retire.py
          else
            echo "‚ö†Ô∏è  RetireJS JSON report not found"
            echo "Creating placeholder report..."
            cat > retirejs-reports/retirejs-readable-report.txt << 'EOFR'
          RetireJS scan completed but no JSON output was generated.
          Check scan-output.txt for raw scan results.
          EOFR
          fi

          # Display preview
          echo ""
          echo "Preview of readable report:"
          echo "=============================="
          head -50 retirejs-reports/retirejs-readable-report.txt
          echo "=============================="
          echo "(Full report available in artifact download)"
        continue-on-error: true

      - name: Display Scan Summary
        if: always()
        run: |
          echo ""
          echo "üìä RetireJS Scan Summary"
          echo "========================"

          # Count findings from scan output
          if [ -f "retirejs-reports/scan-output.txt" ]; then
            VULNERABLE_LIBS=$(grep -c "has known vulnerabilities" retirejs-reports/scan-output.txt || echo "0")
            echo "Vulnerable libraries detected: $VULNERABLE_LIBS"
          fi

          echo ""
          echo "üìÑ Generated Reports:"
          ls -lh retirejs-reports/
          echo ""
          echo "‚ö†Ô∏è  Note: Juice Shop intentionally uses vulnerable libraries for training"
          echo "üìö Reference: https://github.com/RetireJS/retire.js"

      - name: Upload RetireJS Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-retirejs
          path: |
            retirejs-reports/retirejs-report.json
            retirejs-reports/retirejs-sbom.json
            retirejs-reports/retirejs-readable-report.txt
            retirejs-reports/scan-output.txt
          retention-days: 30

  # Stage 3c: Gitleaks
  gitleaks:
    name: Gitleaks Secrets
    runs-on: ubuntu-latest
    needs: [sast, secret-detection, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        run: |
          echo "üîê Running Gitleaks secret scan..."
          docker run --rm -v $(pwd):/repo zricethezav/gitleaks:latest detect --source /repo --verbose > gitleaks-report.txt 2>&1 || echo "‚ö†Ô∏è  Secrets found (warning mode)"
          cat gitleaks-report.txt || echo "No secrets detected"
        continue-on-error: true

      - name: Upload Gitleaks Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-gitleaks
          path: gitleaks-report.txt
          retention-days: 30

  # Stage 3d: Dockerfile Policy
  dockerfile-policy:
    name: Dockerfile Policy (OPA)
    runs-on: ubuntu-latest
    needs: [sast, secret-detection, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Dockerfile Policy Scan
        run: |
          echo "üìã Running OPA/Conftest policy validation..."
          echo "Using comprehensive security policy from docs/docker/dockerfile-security.rego"
          echo "Using docker-based conftest (no binary installation needed)"
          echo ""

          echo "üîç Testing Dockerfile against comprehensive security policies..." | tee dockerfile-policy.txt
          echo "" | tee -a dockerfile-policy.txt
          echo "Security checks include:" | tee -a dockerfile-policy.txt
          echo "  ‚úì No secrets in ENV variables" | tee -a dockerfile-policy.txt
          echo "  ‚úì Use trusted base images only" | tee -a dockerfile-policy.txt
          echo "  ‚úì No 'latest' tag for base images" | tee -a dockerfile-policy.txt
          echo "  ‚úì Avoid curl bashing" | tee -a dockerfile-policy.txt
          echo "  ‚úì No system package upgrades in Dockerfile" | tee -a dockerfile-policy.txt
          echo "  ‚úì Use COPY instead of ADD" | tee -a dockerfile-policy.txt
          echo "  ‚úì Don't run as root user" | tee -a dockerfile-policy.txt
          echo "  ‚úì Don't use sudo command" | tee -a dockerfile-policy.txt
          echo "  ‚úì Use multi-stage builds" | tee -a dockerfile-policy.txt
          echo "" | tee -a dockerfile-policy.txt

          # Use docker-based conftest with comprehensive policy
          set +e  # Disable exit on error for proper handling
          docker run --rm -v $(pwd):/project \
            openpolicyagent/conftest:latest \
            test --policy ./docs/docker/dockerfile-security.rego Dockerfile 2>&1 | tee -a dockerfile-policy.txt
          CONFTEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          echo "" | tee -a dockerfile-policy.txt
          if [ $CONFTEST_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è  Policy violations found (exit code: $CONFTEST_EXIT_CODE)" | tee -a dockerfile-policy.txt
            echo "üìù This is expected for training - Juice Shop is intentionally vulnerable" | tee -a dockerfile-policy.txt
            echo "üìö Reference: https://cloudberry.engineering/article/dockerfile-security-best-practices/" | tee -a dockerfile-policy.txt
            echo "‚úÖ Pipeline continues in warning mode" | tee -a dockerfile-policy.txt
          else
            echo "‚úÖ All Dockerfile policies passed!" | tee -a dockerfile-policy.txt
          fi
        continue-on-error: true

      - name: Upload Dockerfile Policy Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-dockerfile-policy
          path: dockerfile-policy.txt
          retention-days: 30

  # Stage 4: SonarQube (NEW - Manual gate)
  sonar:
    name: SonarQube Code Quality
    runs-on: ubuntu-latest
    needs: [npm-audit, retirejs, gitleaks, dockerfile-policy]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: echo "Sonar stage - dependencies installed in sonar scanner"

      - name: SonarQube Scan (placeholder)
        run: |
          echo "üìä SonarQube analysis would run here"
          echo "‚ö†Ô∏è  Note: SonarQube requires server setup"
          echo "   Deferred to last phase - will implement SonarCloud integration"
          # TODO: Implement SonarCloud in last phase (requires account setup)
        continue-on-error: true

  # Stage 5: Build (existing)
  build:
    name: Build & Tag Docker Image
    runs-on: ubuntu-latest
    needs: sonar
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        run: |
          docker build -t juice-shop:latest .
          echo "‚úÖ Docker image built successfully!"

      - name: Tag images
        run: |
          docker tag juice-shop:latest juice-shop:${{ github.sha }}
          docker tag juice-shop:latest juice-shop:enhanced
          echo "üè∑Ô∏è  Images tagged"

      - name: Save Docker image as artifact
        run: |
          docker save juice-shop:latest -o juice-shop-image.tar
          echo "üíæ Docker image saved"

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: juice-shop-image.tar
          retention-days: 1

  # Stage 5b: Trivy Container Scan (Security Gate Before Push)
  trivy:
    name: Trivy - Scan Built Image
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker image
        run: |
          echo "üì¶ Loading built Docker image..."
          docker load -i juice-shop-image.tar
          echo "‚úÖ Image loaded: juice-shop:latest"

      - name: Run Trivy Container Scan
        run: |
          echo "üê≥ Running Trivy container security scan..."
          echo "Scanning the actual image that will be pushed to production"
          echo ""

          echo "=== Trivy Scan - HIGH Severity (Warning) ===" | tee trivy-scan.txt
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $HOME/.cache:/root/.cache/ \
            aquasec/trivy:latest image --exit-code 0 --severity HIGH --light juice-shop:latest \
            2>&1 | tee -a trivy-scan.txt \
            || echo "‚ö†Ô∏è  HIGH severity vulnerabilities found"

          echo "" | tee -a trivy-scan.txt
          echo "=== Trivy Scan - CRITICAL Severity ===" | tee -a trivy-scan.txt
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $HOME/.cache:/root/.cache/ \
            aquasec/trivy:latest image --exit-code 0 --severity CRITICAL --light juice-shop:latest \
            2>&1 | tee -a trivy-scan.txt \
            || echo "‚ö†Ô∏è  CRITICAL vulnerabilities found (warning mode for training)"

          echo "" | tee -a trivy-scan.txt
          echo "üìä Trivy scan completed" | tee -a trivy-scan.txt
          echo "‚ö†Ô∏è  Note: Pipeline continues even with vulnerabilities (warning mode)"
          echo "üöÄ Proceeding to push stage..."
        continue-on-error: true

      - name: Upload Trivy Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: container-scan-trivy
          path: trivy-scan.txt
          retention-days: 30

  # Stage 6: Push (existing)
  push-to-dockerhub:
    name: Push to Docker Hub
    runs-on: ubuntu-latest
    needs: trivy
    env:
      DOCKER_USERNAME: rupeedev
      DOCKER_REPO: owasp-juice-shop
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker image
        run: docker load -i juice-shop-image.tar

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Tag and push images
        run: |
          docker tag juice-shop:latest ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:latest
          docker tag juice-shop:latest ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:${{ github.sha }}
          docker tag juice-shop:latest ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:enhanced

          docker push ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:latest
          docker push ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:${{ github.sha }}
          docker push ${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:enhanced

  # Stage 7: Deploy (existing)
  deploy:
    name: Deploy to Kubernetes
    runs-on: self-hosted
    needs: push-to-dockerhub
    env:
      DOCKER_USERNAME: rupeedev
      DOCKER_REPO: owasp-juice-shop
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          if ! command -v kubectl &> /dev/null; then
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi

      - name: Verify Kind cluster connectivity
        run: |
          echo "üîç Checking Kind cluster status..."
          kubectl cluster-info
          kubectl get nodes

          echo ""
          echo "üìã Checking existing deployments..."
          kubectl get deployments -A || true
          kubectl get pods -A || true

      - name: Apply manifests
        run: |
          kubectl apply -f kind-k8s-cluster/juice-shop-deployment.yaml
          kubectl apply -f kind-k8s-cluster/juice-shop-service.yaml

      - name: Update deployment
        run: |
          kubectl set image deployment/juice-shop juice-shop=${{ env.DOCKER_USERNAME }}/${{ env.DOCKER_REPO }}:${{ github.sha }}

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/juice-shop --timeout=180s

      - name: Verify deployment
        run: |
          kubectl get pods -l app=juice-shop
          kubectl get svc juice-shop
          kubectl get deployment juice-shop

      - name: Get service endpoint and test connectivity
        run: |
          echo "üåê Getting Kind cluster access information..."

          # Get the Kind node IP (Docker container IP)
          KIND_NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "Kind Node IP: $KIND_NODE_IP"

          # For Kind cluster, the service is accessible via Docker network
          # Test multiple access methods
          echo ""
          echo "Testing connectivity methods:"

          # Method 1: Via localhost (Kind port mapping)
          echo "1. Testing localhost:30080..."
          curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://localhost:30080 || echo "localhost:30080 not accessible"

          # Method 2: Via Kind node IP
          echo "2. Testing ${KIND_NODE_IP}:30080..."
          curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://${KIND_NODE_IP}:30080 || echo "${KIND_NODE_IP}:30080 not accessible"

          # Method 3: Via Kind container name
          echo "3. Testing kind-control-plane:30080..."
          curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://kind-control-plane:30080 || echo "kind-control-plane:30080 not accessible"

          # Store the working endpoint for subsequent stages
          echo ""
          echo "üìç Application endpoints:"
          echo "   - NodePort: http://localhost:30080"
          echo "   - Kind Node: http://${KIND_NODE_IP}:30080"
          echo "   - Container: http://kind-control-plane:30080"
        id: endpoint

  # Stage 8: K8s Security (NEW - DAST with Parallel Execution)
  # Stage 8a: K8s Manifest Security (Parallel - doesn't need app)
  k8s-manifest-scan:
    name: K8s Manifest Security
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run K8s Manifest Security Scan
        run: |
          echo "üîê Scanning Kubernetes manifests for security issues..." | tee k8s-manifest-scan.txt
          echo "" | tee -a k8s-manifest-scan.txt

          # Scan deployment and service manifests with OPA Conftest
          echo "=== Scanning K8s Deployment Manifest ===" | tee -a k8s-manifest-scan.txt
          docker run --rm -v $(pwd):/project \
            openpolicyagent/conftest:latest \
            test --policy ./policy kind-k8s-cluster/juice-shop-deployment.yaml \
            2>&1 | tee -a k8s-manifest-scan.txt \
            || echo "‚ö†Ô∏è  Policy violations in deployment manifest" | tee -a k8s-manifest-scan.txt

          echo "" | tee -a k8s-manifest-scan.txt
          echo "=== Scanning K8s Service Manifest ===" | tee -a k8s-manifest-scan.txt
          docker run --rm -v $(pwd):/project \
            openpolicyagent/conftest:latest \
            test --policy ./policy kind-k8s-cluster/juice-shop-service.yaml \
            2>&1 | tee -a k8s-manifest-scan.txt \
            || echo "‚ö†Ô∏è  Policy violations in service manifest" | tee -a k8s-manifest-scan.txt

          echo "" | tee -a k8s-manifest-scan.txt
          echo "üìù K8s manifest scan checks for:" | tee -a k8s-manifest-scan.txt
          echo "   - Containers running as non-root (runAsNonRoot)" | tee -a k8s-manifest-scan.txt
          echo "   - Security context settings" | tee -a k8s-manifest-scan.txt
          echo "   - Service type configurations" | tee -a k8s-manifest-scan.txt
          echo "   - Resource limits and requests" | tee -a k8s-manifest-scan.txt
          echo "üìö Reference: Best practices from DevSecOps patterns" | tee -a k8s-manifest-scan.txt
        continue-on-error: true

      - name: Upload K8s Manifest Scan Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: k8s-security-k8s-manifest
          path: k8s-manifest-scan.txt
          retention-days: 30

  # Stage 8b: Security Headers Analysis (Parallel - needs app)
  security-headers-scan:
    name: Security Headers Analysis
    runs-on: self-hosted
    needs: deploy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl (if not present)
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "üì• Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
            echo "‚úÖ kubectl installed"
          else
            echo "‚úÖ kubectl already installed"
          fi

      - name: Wait for application readiness
        run: |
          echo "‚è≥ Waiting for application to be ready..."
          sleep 30
          kubectl wait --for=condition=ready pod -l app=juice-shop --timeout=120s

      - name: Detect Kind cluster access method
        id: detect-access
        run: |
          echo "üîç Detecting best access method for Kind cluster..."

          # Get Kind node IP
          KIND_NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "Kind Node IP: $KIND_NODE_IP"

          # Test access methods in order of preference
          APP_URL=""

          # Method 1: localhost (if Kind has port mapping)
          if curl -s -o /dev/null -w "%{http_code}" http://localhost:30080 2>/dev/null | grep -q "200"; then
            APP_URL="http://localhost:30080"
            echo "‚úÖ Access via localhost:30080"
          # Method 2: Kind node IP
          elif curl -s -o /dev/null -w "%{http_code}" http://${KIND_NODE_IP}:30080 2>/dev/null | grep -q "200"; then
            APP_URL="http://${KIND_NODE_IP}:30080"
            echo "‚úÖ Access via ${KIND_NODE_IP}:30080"
          # Method 3: Docker container name
          elif curl -s -o /dev/null -w "%{http_code}" http://kind-control-plane:30080 2>/dev/null | grep -q "200"; then
            APP_URL="http://kind-control-plane:30080"
            echo "‚úÖ Access via kind-control-plane:30080"
          else
            echo "‚ùå No accessible endpoint found"
            APP_URL="http://localhost:30080"  # Fallback
          fi

          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Selected URL: $APP_URL"

      - name: Application Health Check
        env:
          APP_URL: ${{ steps.detect-access.outputs.app_url }}
        run: |
          echo "üè• Checking application health at ${APP_URL}..."
          echo "Waiting for application to start responding..."

          MAX_RETRIES=10
          RETRY_COUNT=0
          SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."

            # Capture both HTTP code and curl exit code
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL} 2>&1 || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Application is responding (HTTP $HTTP_CODE)"
              SUCCESS=true
              break
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "‚ö†Ô∏è  Connection failed - application not ready yet"
            else
              echo "‚ö†Ô∏è  Application returned HTTP $HTTP_CODE"
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Waiting 10 seconds before retry..."
              sleep 10
            fi
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Application health check failed after $MAX_RETRIES attempts"
            echo "Checking pod status:"
            kubectl get pods -l app=juice-shop
            kubectl describe pod -l app=juice-shop | tail -50
            exit 1
          fi
        continue-on-error: true

      - name: Run Security Headers Analysis
        if: always()
        env:
          APP_URL: ${{ steps.detect-access.outputs.app_url }}
        run: |
          set +e  # Don't exit on error

          echo "üîí Analyzing HTTP security headers..." | tee security-headers-scan.txt
          echo "Target: ${APP_URL}" | tee -a security-headers-scan.txt
          echo "" | tee -a security-headers-scan.txt

          # Check if application is accessible
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL} 2>&1 || echo "000")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Application not accessible (HTTP $HTTP_CODE)" | tee -a security-headers-scan.txt
            echo "" | tee -a security-headers-scan.txt
            echo "=== Scan Status ===" | tee -a security-headers-scan.txt
            echo "The security headers scan could not be completed because the application" | tee -a security-headers-scan.txt
            echo "is not accessible at ${APP_URL}" | tee -a security-headers-scan.txt
            echo "" | tee -a security-headers-scan.txt
            echo "Possible reasons:" | tee -a security-headers-scan.txt
            echo "  - Application not fully deployed" | tee -a security-headers-scan.txt
            echo "  - Pod not in ready state" | tee -a security-headers-scan.txt
            echo "  - Service not exposing port correctly" | tee -a security-headers-scan.txt
            echo "  - Kind cluster networking issue" | tee -a security-headers-scan.txt
            echo "" | tee -a security-headers-scan.txt
            echo "Check pod status:" | tee -a security-headers-scan.txt
            kubectl get pods -l app=juice-shop 2>&1 | tee -a security-headers-scan.txt || true
            exit 0  # Exit successfully to allow artifact upload
          fi

          echo "‚úÖ Application accessible (HTTP $HTTP_CODE)" | tee -a security-headers-scan.txt
          echo "" | tee -a security-headers-scan.txt
          echo "=== Current Security Headers ===" | tee -a security-headers-scan.txt
          curl -s -D - ${APP_URL} -o /dev/null 2>&1 | grep -E "^X-|^Content-Security|^Strict-Transport" | tee -a security-headers-scan.txt || echo "(No security headers found)" | tee -a security-headers-scan.txt
          echo "" | tee -a security-headers-scan.txt
          echo "=== Security Header Assessment ===" | tee -a security-headers-scan.txt

          HEADERS=$(curl -s -D - ${APP_URL} -o /dev/null 2>&1)

          # Check for present headers
          echo "$HEADERS" | grep -q "X-Content-Type-Options" && echo "‚úì X-Content-Type-Options: Present" | tee -a security-headers-scan.txt || echo "‚úó X-Content-Type-Options: Missing" | tee -a security-headers-scan.txt
          echo "$HEADERS" | grep -q "X-Frame-Options" && echo "‚úì X-Frame-Options: Present" | tee -a security-headers-scan.txt || echo "‚úó X-Frame-Options: Missing" | tee -a security-headers-scan.txt
          echo "$HEADERS" | grep -q "Content-Security-Policy" && echo "‚úì Content-Security-Policy: Present" | tee -a security-headers-scan.txt || echo "‚úó Content-Security-Policy: Missing (expected)" | tee -a security-headers-scan.txt
          echo "$HEADERS" | grep -q "Strict-Transport-Security" && echo "‚úì Strict-Transport-Security: Present" | tee -a security-headers-scan.txt || echo "‚úó Strict-Transport-Security: Missing (expected)" | tee -a security-headers-scan.txt
          echo "$HEADERS" | grep -q "X-XSS-Protection" && echo "‚úì X-XSS-Protection: Present" | tee -a security-headers-scan.txt || echo "‚úó X-XSS-Protection: Missing (expected)" | tee -a security-headers-scan.txt
          echo "" | tee -a security-headers-scan.txt
          echo "‚ö†Ô∏è  Note: Juice Shop is intentionally vulnerable - missing headers are expected" | tee -a security-headers-scan.txt
        continue-on-error: true

      - name: Upload Security Headers Scan Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: k8s-security-security-headers
          path: security-headers-scan.txt
          retention-days: 30

  # Stage 8c: OWASP ZAP Baseline (Parallel - needs app)
  owasp-zap-scan:
    name: OWASP ZAP Baseline
    runs-on: self-hosted
    needs: deploy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl (if not present)
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "üì• Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
            echo "‚úÖ kubectl installed"
          else
            echo "‚úÖ kubectl already installed"
          fi

      - name: Wait for application readiness
        run: |
          echo "‚è≥ Waiting for application to be ready..."
          sleep 30
          kubectl wait --for=condition=ready pod -l app=juice-shop --timeout=120s

      - name: Detect Kind cluster access method for ZAP
        id: detect-zap-access
        run: |
          echo "üîç Detecting best access method for ZAP scan..."

          # Get Kind node IP
          KIND_NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "Kind Node IP: $KIND_NODE_IP"

          # Get Kind container name
          KIND_CONTAINER=$(docker ps --filter "name=kind-control-plane" --format "{{.Names}}" | head -1)
          echo "Kind Container: $KIND_CONTAINER"

          # For ZAP running in Docker, we need to use an address accessible from Docker network
          # Test access methods in order of preference
          ZAP_TARGET_URL=""
          ACCESS_METHOD=""

          # Method 1: Kind container IP (most reliable for Docker-to-Docker)
          if [ -n "$KIND_NODE_IP" ]; then
            # Test if accessible
            if curl -s -o /dev/null -w "%{http_code}" http://${KIND_NODE_IP}:30080 2>/dev/null | grep -q "200"; then
              ZAP_TARGET_URL="http://${KIND_NODE_IP}:30080"
              ACCESS_METHOD="kind-node-ip"
              echo "‚úÖ Will use Kind Node IP for ZAP: ${KIND_NODE_IP}:30080"
            fi
          fi

          # Method 2: host.docker.internal (works on Docker Desktop)
          if [ -z "$ZAP_TARGET_URL" ]; then
            if docker run --rm curlimages/curl:latest curl -s -o /dev/null -w "%{http_code}" http://host.docker.internal:30080 2>/dev/null | grep -q "200"; then
              ZAP_TARGET_URL="http://host.docker.internal:30080"
              ACCESS_METHOD="host-docker-internal"
              echo "‚úÖ Will use host.docker.internal for ZAP"
            fi
          fi

          # Method 3: Kind container name via Docker network
          if [ -z "$ZAP_TARGET_URL" ] && [ -n "$KIND_CONTAINER" ]; then
            ZAP_TARGET_URL="http://${KIND_CONTAINER}:30080"
            ACCESS_METHOD="kind-container-name"
            echo "‚úÖ Will use Kind container name for ZAP: ${KIND_CONTAINER}:30080"
          fi

          # Fallback: Use Kind node IP even if test failed
          if [ -z "$ZAP_TARGET_URL" ]; then
            ZAP_TARGET_URL="http://${KIND_NODE_IP}:30080"
            ACCESS_METHOD="fallback-kind-ip"
            echo "‚ö†Ô∏è  Using fallback: ${KIND_NODE_IP}:30080"
          fi

          echo "zap_target_url=$ZAP_TARGET_URL" >> $GITHUB_OUTPUT
          echo "access_method=$ACCESS_METHOD" >> $GITHUB_OUTPUT
          echo "kind_network=$(docker network ls --filter name=kind --format '{{.Name}}' | head -1)" >> $GITHUB_OUTPUT
          echo "Selected ZAP target: $ZAP_TARGET_URL (Method: $ACCESS_METHOD)"

      - name: Application Health Check
        run: |
          echo "üè• Checking application health from runner host..."

          MAX_RETRIES=10
          RETRY_COUNT=0
          SUCCESS=false

          # Get Kind node IP for health check
          KIND_NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."

            # Try multiple endpoints
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:30080 2>/dev/null | grep -q "200"; then
              echo "‚úÖ Application accessible via localhost:30080"
              SUCCESS=true
              break
            elif curl -s -o /dev/null -w "%{http_code}" http://${KIND_NODE_IP}:30080 2>/dev/null | grep -q "200"; then
              echo "‚úÖ Application accessible via ${KIND_NODE_IP}:30080"
              SUCCESS=true
              break
            else
              echo "‚ö†Ô∏è  Application not ready yet"
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Waiting 10 seconds before retry..."
              sleep 10
            fi
          done

          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Application health check failed after $MAX_RETRIES attempts"
            echo "Checking pod status:"
            kubectl get pods -l app=juice-shop
            kubectl describe pod -l app=juice-shop | tail -50
            exit 1
          fi
        continue-on-error: true

      - name: Run OWASP ZAP Baseline Scan
        if: always()
        env:
          ZAP_TARGET_URL: ${{ steps.detect-zap-access.outputs.zap_target_url }}
          ACCESS_METHOD: ${{ steps.detect-zap-access.outputs.access_method }}
          KIND_NETWORK: ${{ steps.detect-zap-access.outputs.kind_network }}
        run: |
          set +e  # Don't exit on error

          echo "üîç Running OWASP ZAP baseline scan..."
          echo "Target: ${ZAP_TARGET_URL}"
          echo "Access Method: ${ACCESS_METHOD}"
          echo "Note: This may take 2-5 minutes..."

          # Check if Docker is available
          if ! command -v docker &> /dev/null; then
            echo "‚ùå Docker is not installed on this runner"
            echo "<html><body><h1>ZAP Scan - Docker Not Available</h1>" > zap-report.html
            echo "<p>The OWASP ZAP scan could not run because Docker is not installed on the self-hosted runner.</p>" >> zap-report.html
            echo "<h2>Resolution</h2><ul>" >> zap-report.html
            echo "<li>Install Docker on the self-hosted runner</li>" >> zap-report.html
            echo "<li>Or use a GitHub-hosted runner (but it won't have access to localhost:30080)</li></ul>" >> zap-report.html
            echo "</body></html>" >> zap-report.html
            echo "‚ö†Ô∏è  Created diagnostic report"
            exit 0
          fi

          # Check if Docker daemon is running
          if ! docker ps &> /dev/null; then
            echo "‚ùå Docker daemon is not running"
            echo "<html><body><h1>ZAP Scan - Docker Daemon Not Running</h1>" > zap-report.html
            echo "<p>The OWASP ZAP scan could not run because the Docker daemon is not running.</p>" >> zap-report.html
            echo "<h2>Resolution</h2><ul>" >> zap-report.html
            echo "<li>Start Docker daemon: <code>sudo systemctl start docker</code></li>" >> zap-report.html
            echo "<li>Enable Docker on boot: <code>sudo systemctl enable docker</code></li></ul>" >> zap-report.html
            echo "</body></html>" >> zap-report.html
            echo "‚ö†Ô∏è  Created diagnostic report"
            exit 0
          fi

          echo "‚úÖ Docker available and daemon running"

          # Create directory for ZAP reports
          mkdir -p ${{ github.workspace }}/zap-reports

          # Determine network mode
          if [ "$ACCESS_METHOD" = "kind-node-ip" ] || [ "$ACCESS_METHOD" = "fallback-kind-ip" ]; then
            # Use host network mode for Kind node IP access
            NETWORK_MODE="host"
            echo "Using Docker network mode: host"
          elif [ -n "$KIND_NETWORK" ]; then
            # Use Kind network for container-to-container communication
            NETWORK_MODE="$KIND_NETWORK"
            echo "Using Docker network mode: $KIND_NETWORK"
          else
            # Fallback to host network
            NETWORK_MODE="host"
            echo "Using Docker network mode: host (fallback)"
          fi

          # Run ZAP scan with appropriate network configuration
          echo "Starting ZAP scan targeting: ${ZAP_TARGET_URL}"
          timeout 300 docker run --rm --network ${NETWORK_MODE} \
            -v ${{ github.workspace }}/zap-reports:/zap/wrk:rw \
            zaproxy/zap-stable:latest \
            zap-baseline.py -t ${ZAP_TARGET_URL} -I -r zap-report.html \
            || ZAP_EXIT_CODE=$?

          if [ -n "$ZAP_EXIT_CODE" ]; then
            echo "‚ö†Ô∏è  ZAP scan exited with code: $ZAP_EXIT_CODE (security issues found or scan timed out - warning mode)"
          fi

          # Move report to workspace root for artifact upload
          if [ -f "${{ github.workspace }}/zap-reports/zap-report.html" ]; then
            mv ${{ github.workspace }}/zap-reports/zap-report.html ${{ github.workspace }}/
            echo "‚úÖ ZAP report saved to workspace"
          else
            echo "‚ö†Ô∏è  ZAP report not generated, creating diagnostic report"
            echo "<html><body><h1>ZAP Scan - Report Not Generated</h1>" > ${{ github.workspace }}/zap-report.html
            echo "<p>The ZAP scan did not generate a report.</p>" >> ${{ github.workspace }}/zap-report.html
            echo "<h2>Configuration Used</h2><ul>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Target URL: ${ZAP_TARGET_URL}</li>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Access Method: ${ACCESS_METHOD}</li>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Network Mode: ${NETWORK_MODE}</li>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Exit Code: ${ZAP_EXIT_CODE:-unknown}</li>" >> ${{ github.workspace }}/zap-report.html
            echo "</ul>" >> ${{ github.workspace }}/zap-report.html
            echo "<h2>Possible Issues</h2><ul>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Target application not accessible from ZAP container</li>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Network configuration mismatch</li>" >> ${{ github.workspace }}/zap-report.html
            echo "<li>Scan timeout (5 minutes)</li>" >> ${{ github.workspace }}/zap-report.html
            echo "</ul></body></html>" >> ${{ github.workspace }}/zap-report.html
          fi

          echo "üìä ZAP scan process completed"
          echo "‚ö†Ô∏è  Findings are expected for intentionally vulnerable application"
        continue-on-error: true

      - name: Upload OWASP ZAP Scan Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: k8s-security-owasp-zap
          path: zap-report.html
          retention-days: 30

  # Stage 9: OWASP Noir - Attack Surface Detection & Analysis
  noir-attack-surface-analysis:
    name: OWASP Noir - Attack Surface Detection
    runs-on: ubuntu-latest
    needs: [k8s-manifest-scan, security-headers-scan, owasp-zap-scan]
    if: always()  # Run even if previous stages have failures
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq for JSON processing
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq

      - name: Run OWASP Noir Attack Surface Scan
        run: |
          echo "üîç Running OWASP Noir attack surface detection..." | tee noir-scan.txt
          echo "" | tee -a noir-scan.txt
          echo "=== OWASP Noir - Static Analysis for API Endpoints ===" | tee -a noir-scan.txt
          echo "Technology: Identifies attack surfaces by analyzing source code" | tee -a noir-scan.txt
          echo "Scope: API endpoints, parameters, potential vulnerabilities" | tee -a noir-scan.txt
          echo "" | tee -a noir-scan.txt

          # Run Noir scan and capture results
          docker run --rm -v $(pwd):/target \
            ghcr.io/owasp-noir/noir:latest \
            noir -b /target -f json > noir-results.json 2>&1 || echo "‚ö†Ô∏è  Noir scan completed with findings"

          # Check if results file exists and has content
          if [ -f "noir-results.json" ] && [ -s "noir-results.json" ]; then
            echo "‚úÖ Noir scan completed successfully" | tee -a noir-scan.txt
            echo "" | tee -a noir-scan.txt

            # Extract endpoint count using jq
            ENDPOINT_COUNT=$(jq '.endpoints | length' noir-results.json 2>/dev/null || echo "0")
            echo "üìä Scan Results:" | tee -a noir-scan.txt
            echo "   Total Endpoints Discovered: $ENDPOINT_COUNT" | tee -a noir-scan.txt
            echo "" | tee -a noir-scan.txt

            # Display endpoint details (first 20 endpoints with methods and parameters)
            echo "=== Discovered Endpoints (First 20) ===" | tee -a noir-scan.txt
            jq -r '.endpoints[:20] | .[] | "  ‚Ä¢ [\(.method)] \(.url)\n    Params: \(if .params | length > 0 then (.params | map(.name) | join(", ")) else "none" end)\n    File: \(.details.code_paths[0].path // "unknown"):\(.details.code_paths[0].line // "?")"' noir-results.json 2>/dev/null | tee -a noir-scan.txt || echo "  Unable to parse endpoint details" | tee -a noir-scan.txt
            echo "" | tee -a noir-scan.txt

            # Extract HTTP methods breakdown
            echo "=== HTTP Methods Distribution ===" | tee -a noir-scan.txt
            jq -r '.endpoints | group_by(.method) | .[] | "  ‚Ä¢ \(.[0].method): \(length) endpoints"' noir-results.json 2>/dev/null | tee -a noir-scan.txt || echo "  Unable to parse methods" | tee -a noir-scan.txt
            echo "" | tee -a noir-scan.txt

            # Extract vulnerability tags if any
            echo "=== Potential Vulnerability Indicators ===" | tee -a noir-scan.txt
            VULN_COUNT=$(jq '[.endpoints[].params[]?.tags[]? | select(.tagger == "Hunt")] | length' noir-results.json 2>/dev/null || echo "0")
            if [ "$VULN_COUNT" -gt 0 ]; then
              echo "   ‚ö†Ô∏è  Found $VULN_COUNT parameters with vulnerability tags:" | tee -a noir-scan.txt
              jq -r '[.endpoints[] | select(.params[]?.tags[]?.tagger == "Hunt") | "  ‚Ä¢ [\(.method)] \(.url) - Param: \(.params[] | select(.tags[]?.tagger == "Hunt") | .name) (\(.params[] | select(.tags[]?.tagger == "Hunt") | .tags[].name))"] | .[]' noir-results.json 2>/dev/null | head -10 | tee -a noir-scan.txt || echo "  Unable to extract vulnerability tags" | tee -a noir-scan.txt
            else
              echo "   No specific vulnerability tags detected by Noir" | tee -a noir-scan.txt
            fi
            echo "" | tee -a noir-scan.txt

            # Extract unique file paths analyzed
            echo "=== Source Files Analyzed ===" | tee -a noir-scan.txt
            FILE_COUNT=$(jq '[.endpoints[].details.code_paths[].path] | unique | length' noir-results.json 2>/dev/null || echo "0")
            echo "   Total Source Files: $FILE_COUNT" | tee -a noir-scan.txt
            echo "   Sample Files:" | tee -a noir-scan.txt
            jq -r '[.endpoints[].details.code_paths[].path] | unique | .[:10] | .[] | "     - \(.)"' noir-results.json 2>/dev/null | tee -a noir-scan.txt || echo "     Unable to list files" | tee -a noir-scan.txt
            echo "" | tee -a noir-scan.txt
          else
            echo "‚ö†Ô∏è  Noir results not generated or empty" | tee -a noir-scan.txt
            echo "Check if Noir supports the project's language/framework" | tee -a noir-scan.txt
            echo "" | tee -a noir-scan.txt
          fi

          echo "üìù Attack Surface Analysis Summary:" | tee -a noir-scan.txt
          echo "   ‚Ä¢ API endpoint discovery via static analysis" | tee -a noir-scan.txt
          echo "   ‚Ä¢ Parameter extraction and mapping" | tee -a noir-scan.txt
          echo "   ‚Ä¢ Framework and technology detection" | tee -a noir-scan.txt
          echo "   ‚Ä¢ Source code location tracking" | tee -a noir-scan.txt
          echo "   ‚Ä¢ Vulnerability pattern identification" | tee -a noir-scan.txt
          echo "" | tee -a noir-scan.txt
          echo "‚ö†Ô∏è  Note: Juice Shop has many intentional vulnerabilities" | tee -a noir-scan.txt
          echo "üìö Reference: https://github.com/owasp-noir/noir" | tee -a noir-scan.txt
        continue-on-error: true

      - name: Upload Noir JSON Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: noir-attack-surface-json
          path: noir-results.json
          retention-days: 30

      - name: Upload Noir Scan Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: noir-attack-surface-report
          path: noir-scan.txt
          retention-days: 30

  # Final success message
  pipeline-complete:
    name: Pipeline Complete
    runs-on: ubuntu-latest
    needs: noir-attack-surface-analysis
    steps:
      - name: Success message
        run: |
          echo "üéâ Enhanced Pipeline completed successfully!"
          echo ""
          echo "‚úÖ Pipeline Stages (Parallel Execution Optimized):"
          echo "   Stage 1: Lint ‚úì"
          echo "   Stage 2: SAST + Secret Detection + Unit Tests (parallel) ‚úì"
          echo "   Stage 3: Security Scan (Gitleaks, RetireJS, npm-audit - parallel) ‚úì"
          echo "           + Dockerfile Policy Validation ‚úì"
          echo "   Stage 4: SonarQube Analysis ‚úì"
          echo "   Stage 5: Build & Tag Docker Image ‚úì"
          echo "   Stage 5b: Trivy Container Scan (Security Gate) ‚úì"
          echo "   Stage 6: Push to Docker Hub ‚úì"
          echo "   Stage 7: Deploy to Kubernetes ‚úì"
          echo "   Stage 8: K8s Security + DAST (parallel) ‚úì"
          echo "           ‚Ä¢ K8s Manifest Security ‚úì"
          echo "           ‚Ä¢ Security Headers Analysis ‚úì"
          echo "           ‚Ä¢ OWASP ZAP Baseline Scan ‚úì"
          echo "   Stage 9: OWASP Noir - Attack Surface Detection ‚úì"
          echo ""
          echo "‚ö° Parallel execution: SAST, Secrets, Tests, and Policy checks run simultaneously"
          echo "üîí Security scanning integrated at multiple stages"
          echo "üì¶ Application deployed to Kubernetes"
          echo "üåê Access at: http://localhost:30080"
          echo ""
          echo "üìä Security Reports Available as Artifacts:"
          echo "   ‚Ä¢ noir-attack-surface-json - Complete Noir JSON results"
          echo "   ‚Ä¢ noir-attack-surface-report - Formatted attack surface analysis"
          echo "   ‚Ä¢ k8s-security-* - K8s manifest, headers, and ZAP reports"
          echo "   ‚Ä¢ container-scan-trivy - Container vulnerability scan"
          echo "   ‚Ä¢ sast-report - Static analysis results"
