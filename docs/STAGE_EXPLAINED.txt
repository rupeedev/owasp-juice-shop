
PIPELINE EXPLAINED
===================


Key Insight:

  â€¢ npm audit     â†’ Finds vulnerable dependencies (supply chain)
  â€¢ CodeQL        â†’ Finds vulnerable code (application logic)
  â€¢ TruffleHog    â†’ Finds leaked secrets (credentials)
  â€¢ RetireJS      â†’ Finds vulnerable JavaScript libraries (client + server)
  â€¢ Gitleaks      â†’ Finds secrets in git history (commit scanning)
  â€¢ Trivy         â†’ Finds container vulnerabilities (base images + OS packages)
  â€¢ OPA/Conftest  â†’ Finds Dockerfile policy violations (configuration security)
  â€¢ K8s Manifest  â†’ Finds Kubernetes security misconfigurations (deployment security)

TL;DR
-----
Linting = Automated code quality checker that finds bugs, style issues, and
potential errors BEFORE code runs. Think of it as spell-check for code.


Command Execution:
------------------
Run npm run lint
  shell: /usr/bin/bash -e {0}

Meaning:
  â€¢ npm run lint      â†’ Executes the lint script from package.json
  â€¢ /usr/bin/bash     â†’ Uses Bash shell to run the command
  â€¢ -e flag           â†’ Exit immediately if any command fails (error handling)
  â€¢ {0}               â†’ Placeholder for the command to execute




PURPOSE IN CI/CD PIPELINE
============================

Why Lint in Stage 1?
--------------------
âœ“ Catch issues early    â†’ Before running tests or building
âœ“ Fast feedback          â†’ Linting takes seconds, not minutes
âœ“ Prevent tech debt      â†’ Enforce code standards automatically
âœ“ Security baseline      â†’ Detect unsafe patterns early
âœ“ Team consistency       â†’ Everyone follows same code style

Pipeline Position:
------------------
Stage 1: Lint              â† (First quality gate)


INTERPRETATION OF  OUTPUT
==========================

Result: SUCCESS âœ“
-----------------
âœ“ Backend ESLint     â†’ Passed (no errors)
âœ“ Frontend ng lint   â†’ Passed ("All files pass linting.")
âœ“ SCSS Stylelint     â†’ Passed (no output = success)

What this means:
â€¢ Code quality is good
â€¢ No syntax errors detected
â€¢ Consistent code style across project
â€¢ Ready to proceed to next pipeline stages


COMMON LINT ERRORS (What to expect in vulnerable apps)
=======================================================

If linting HAD failed, you might see:

Backend (ESLint):
  âœ— error  'password' is defined but never used        no-unused-vars
  âœ— error  Unexpected console statement                no-console
  âœ— error  'eval' can be harmful                       no-eval
  âœ— error  Missing semicolon                           semi

Frontend (ng lint):
  âœ— error  Component should implement OnDestroy
  âœ— error  Use async pipe instead of manual subscribe

SCSS (stylelint):
  âœ— error  Expected single space after ":"             declaration-colon-space-after
  âœ— error  Unexpected unknown property "colour"        property-no-unknown

================================================================================

================================================================================

STAGE 2: SAST - CodeQL Analysis
================================

TL;DR
-----
SAST = Static Application Security Testing. CodeQL analyzes source code for
security vulnerabilities (SQL injection, XSS, etc.) WITHOUT running the app.
Think of it as a security-focused X-ray of your code.


Command Execution:
------------------
GitHub Actions: CodeQL action workflow

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: javascript, typescript
        queries: security-extended,security-and-quality

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

Meaning:
  â€¢ init@v2              â†’ Sets up CodeQL database for code analysis
  â€¢ languages            â†’ Analyzes JavaScript and TypeScript files
  â€¢ security-extended    â†’ Runs comprehensive security vulnerability checks
  â€¢ analyze@v2           â†’ Executes analysis and uploads to GitHub Security tab
  â€¢ Results              â†’ Available in GitHub Security â†’ Code scanning alerts




PURPOSE IN CI/CD PIPELINE
============================

Why SAST - CodeQL in Stage 2?
------------------------------
âœ“ Shift-left security       â†’ Catch vulnerabilities before deployment
âœ“ Zero false positives      â†’ Semantic analysis, not pattern matching
âœ“ OWASP Top 10 coverage     â†’ Detects all major vulnerability classes
âœ“ GitHub native             â†’ Results in Security tab with PR annotations
âœ“ Data flow tracking        â†’ Traces vulnerabilities across files/functions

Pipeline Position:
------------------
Stage 2: SAST + Secret Detection + Unit Tests (parallel)    â† After Lint


INTERPRETATION OF OUTPUT
==========================

Result: SUCCESS (with security findings tracked separately)
------------------------------------------------------------
CodeQL uploads results to GitHub Security â†’ Code scanning alerts

Typical Juice Shop Findings (intentionally vulnerable app):

âœ“ SQL Injection (CWE-89)           â†’ High Severity
  Location: routes/user.js:45
  "User input flows to SQL query without sanitization"

âœ“ Cross-Site Scripting (CWE-79)    â†’ High Severity
  Location: views/profile.ts:128
  "Unsanitized user data rendered in HTML"

âœ“ Path Traversal (CWE-22)          â†’ Medium Severity
  Location: controllers/file.js:67
  "File path constructed from untrusted input"

âœ“ Command Injection (CWE-78)       â†’ Critical Severity
  Location: routes/exec.ts:34
  "Shell command includes unescaped user data"

What this means:
â€¢ CodeQL found vulnerabilities but didn't fail the build (continue-on-error)
â€¢ Results visible in: GitHub Security tab â†’ Code scanning alerts
â€¢ Each finding shows: file location, data flow path, remediation advice
â€¢ For Juice Shop: These are intentional vulnerabilities for training


COMMON CODEQL ERRORS (What to expect if things fail)
=====================================================

If CodeQL HAD failed, you might see:

Initialization Phase:
  âœ— error  Language 'javascript' not supported              unsupported-language
  âœ— error  Failed to create database                        database-creation-failed
  âœ— error  npm install failed during build                  build-failed

Analysis Phase:
  âœ— error  Out of memory during analysis                    oom-error
  âœ— error  Query timed out after 120 minutes                query-timeout
  âš  warning Some files could not be analyzed                partial-analysis

Upload Phase:
  âœ— error  Failed to upload SARIF results                   sarif-upload-failed
  âš  warning Results exceed 10MB size limit                  results-too-large

What these mean:
  â€¢ database-creation-failed: Source code has syntax errors or build issues
  â€¢ oom-error: Large codebase needs more memory (increase runner size)
  â€¢ query-timeout: Very large repos may need custom timeout configuration
  â€¢ sarif-upload-failed: Check GitHub token permissions for Security tab

================================================================================

Key Insight: CodeQL uses semantic analysis to understand code LOGIC, not just
patterns. It tracks data flow from user input â†’ vulnerable sinks (like SQL
queries), making it far more accurate than regex-based tools.


CodeQL vs SonarQube SAST - Key Differences
===================================================


  Quick Comparison Table

  | Aspect           | CodeQL (GitHub)          | SonarQube                           |
  |------------------|--------------------------|-------------------------------------|
  | Type             | Semantic analysis        | Pattern + rule-based analysis       |
  | Analysis Method  | Data flow tracking       | AST + rules + metrics               |
  | Focus            | Security vulnerabilities | Code quality + security + tech debt |
  | Integration      | Native GitHub            | External server/SonarCloud          |
  | Results Location | GitHub Security tab      | SonarQube dashboard                 |
  | False Positives  | Very low (semantic)      | Higher (pattern matching)           |
  | Setup Complexity | Easy (GitHub Actions)    | Moderate (server setup)             |
  | Cost             | Free for public repos    | Free tier + paid enterprise         |

  ---
  Detailed Comparison

  1. Analysis Approach

  CodeQL:
  User Input â†’ Function â†’ Database Query
       â†“           â†“            â†“
    [SOURCE]   [SANITIZER]   [SINK]
  - Traces data flow from sources to sinks
  - Understands code semantics and logic
  - Example: "User input from req.body.username flows to SQL query at line 45"

  SonarQube:
  Code â†’ Parse â†’ Check Rules â†’ Report Issues
           â†“         â†“             â†“
         AST    Pattern Match   Metrics
  - Checks against predefined rules
  - AST (Abstract Syntax Tree) analysis
  - Example: "SQL query uses string concatenation (pattern detected)"

  ---
  2. What They Find

  CodeQL Strengths:
  âœ… Complex vulnerabilities requiring data flow analysis
     â€¢ SQL Injection with multi-step taint flow
     â€¢ XSS across multiple function calls
     â€¢ Path Traversal through variable chains
     â€¢ Command Injection with indirect calls

  Example from your app:
  Location: routes/login.ts:34
  "User input flows to SQL query without sanitization"
       â†“
  CodeQL traces: req.body â†’ variable â†’ SQL query (5 steps)

  SonarQube Strengths:
  âœ… Code quality and maintainability issues
     â€¢ Code smells (duplicated code, long methods)
     â€¢ Cognitive complexity
     â€¢ Test coverage metrics
     â€¢ Technical debt ratio
     â€¢ Security hotspots (requires review)
     â€¢ OWASP Top 10 mapping

  Example issues:
  - "Method has cognitive complexity of 25 (max 15)"
  - "4 duplicated code blocks detected"
  - "Missing unit tests for this component"
  - "Password hardcoded in source code" (security hotspot)

  ---
  3. Security Coverage

  CodeQL:
  - Deep dive: Tracks vulnerabilities through entire codebase
  - OWASP Top 10: âœ… All covered with high accuracy
  - CWE Coverage: 300+ CWE patterns
  - Result: Critical/High severity vulnerabilities

  From your pipeline (Stage 2):
  âœ“ SQL Injection (CWE-89)      â†’ High Severity
  âœ“ XSS (CWE-79)                â†’ High Severity
  âœ“ Path Traversal (CWE-22)     â†’ Medium Severity
  âœ“ Command Injection (CWE-78)  â†’ Critical Severity

  SonarQube:
  - Broader scope: Security + Quality + Maintainability
  - OWASP Top 10: âœ… Covered with "Security Hotspots"
  - Additional: Code smells, bugs, vulnerabilities, tech debt
  - Result: Bugs, Vulnerabilities, Code Smells, Security Hotspots

  Typical SonarQube report:
  ğŸ“Š Overview:
     Bugs: 12
     Vulnerabilities: 8
     Security Hotspots: 15 (need review)
     Code Smells: 147
     Technical Debt: 2d 4h
     Coverage: 62%
     Duplications: 3.2%

  ---
  4. Integration & Workflow

  CodeQL (Your Pipeline - Stage 2):
  # Stage 2a: SAST (Parallel)
  sast:
    name: SAST - CodeQL Analysis
    - Initialize CodeQL
    - Perform Analysis
    - Upload to GitHub Security
    - Generate readable report  # â† NEW!
    - Upload artifacts (SARIF + readable)

  Results:
  - âœ… GitHub Security tab â†’ Code scanning alerts
  - âœ… PR comments (inline annotations)
  - âœ… Downloadable SARIF files
  - âœ… Human-readable reports (your new feature!)

  SonarQube (Your Pipeline - Stage 4):
  # Stage 4: SonarQube (placeholder)
  sonar:
    name: SonarQube Code Quality
    - Checkout code (fetch-depth: 0 for blame data)
    - Run SonarScanner
    - Upload to SonarQube/SonarCloud
    - Quality Gate check

  Results:
  - âœ… SonarQube Dashboard (web UI)
  - âœ… Quality Gate status (pass/fail)
  - âœ… Project metrics over time
  - âœ… Technical debt tracking

  ---
  5. When to Use Each

  Use CodeQL When:
  âœ… Need deep security vulnerability analysis
  âœ… Working with GitHub repositories
  âœ… Want zero-config security scanning
  âœ… Focus on OWASP Top 10 compliance
  âœ… Need low false-positive rate
  âœ… Want data flow tracking

  Use SonarQube When:
  âœ… Need comprehensive code quality metrics
  âœ… Want to track technical debt over time
  âœ… Need test coverage reporting
  âœ… Want code smell detection
  âœ… Managing multiple projects centrally
  âœ… Need custom quality gates
  âœ… Want historical trend analysis


Secret - Detection - TruffleHog
===================================================
https://github.com/trufflesecurity/trufflehog.git

  Detailed Analysis

  Scan Results:
  {
    "chunks": 2078,                    // Files/code chunks scanned
    "bytes": 11681661,                 // ~11.1 MB of code analyzed
    "verified_secrets": 0,             // âœ… No real secrets found
    "unverified_secrets": 0,           // âœ… No potential secrets found
    "scan_duration": "2.21470108s",    // Fast scan (~2.2 seconds)
    "trufflehog_version": "3.91.1"     // Latest version used
  }

  ---
  What TruffleHog Did

  1. Scanned Your Entire Repository:
  âœ“ 2,078 code chunks analyzed
  âœ“ 11.7 MB of data processed
  âœ“ Full git history scanned (fetch-depth: 0)
  âœ“ All commits, branches, and files checked

  2. Looked For:
  - API keys (AWS, GitHub, Slack, etc.)
  - Database credentials
  - Private keys (SSH, SSL, JWT)
  - OAuth tokens
  - Service account credentials
  - Hardcoded passwords
  - Authentication tokens

  3. Verification Process:
  verification_caching: {
    "Hits": 0,          // No previously cached results
    "Misses": 4,        // Checked 4 potential patterns
    "HitsWasted": 0,    // No false positives
    "AttemptsSaved": 0, // First scan
    "VerificationTimeSpentMS": 1095  // ~1 second verifying
  }

  ---
  Key Findings

  âœ… Verified Secrets: 0
  - No real, active credentials found
  - TruffleHog validates secrets by testing them against services
  - Example: If it finds an AWS key, it tries to authenticate with AWS
  - Result: None found âœ…

  âœ… Unverified Secrets: 0
  - No potential secrets detected
  - No patterns matching secret formats
  - Example: Strings that look like AKIA... (AWS format) but couldn't be verified
  - Result: None found âœ…

  ---
  Non-Critical Error (Line 27)

  âš ï¸ Warning: Could not extract password-protected ZIP
  Location: test/files/passwordProtected.zip
  Reason: Unsupported compression algorithm
  Impact: NONE - Test file, not a security issue

  This is expected:
  - It's a test file in the OWASP Juice Shop test suite
  - Used for testing file upload vulnerabilities
  - TruffleHog couldn't extract it (password protected)
  - Not a security concern




STAGE 3a: npm Audit - Dependency Vulnerability Scanning
========================================================

TL;DR
-----
npm audit = Automated security scanner that checks your dependencies (node_modules)
for known vulnerabilities. Think of it as a security check for third-party code
you're using in your application.


Command Execution:
------------------
Run npm audit --audit-level=moderate
  shell: /usr/bin/bash -e {0}

Meaning:
  â€¢ npm audit              â†’ Scans package.json and package-lock.json
  â€¢ --audit-level=moderate â†’ Report moderate, high, and critical vulnerabilities
  â€¢ Checks against         â†’ National Vulnerability Database (NVD) + npm registry
  â€¢ Output                 â†’ Report with CVE IDs, severity, and remediation

How it works:
  1. Reads package-lock.json to get exact dependency versions
  2. Queries npm registry for known vulnerabilities
  3. Checks both direct and transitive (nested) dependencies
  4. Reports CVEs with severity levels and fix recommendations




PURPOSE IN CI/CD PIPELINE
============================

Why npm Audit in Stage 3a?
---------------------------
âœ“ Supply chain security    â†’ Detect vulnerable dependencies before deployment
âœ“ Compliance requirements   â†’ Meet security standards (OWASP, PCI DSS)
âœ“ Early detection           â†’ Find issues before they reach production
âœ“ Automated remediation     â†’ Get fix recommendations automatically
âœ“ Transitive dependency check â†’ Catches nested dependency vulnerabilities
âœ“ SBOM awareness            â†’ Know what you're shipping

Pipeline Position:
------------------
Stage 3a: npm Audit (Parallel with RetireJS, Gitleaks, Trivy)
             â†“
         Runs after Stage 2 (SAST, Secrets, Tests)


INTERPRETATION OF OUTPUT
==========================

Result: WARNING (vulnerabilities found but pipeline continues)
--------------------------------------------------------------
npm audit report for owasp-juice-shop

Typical Juice Shop Findings (intentionally vulnerable dependencies):

# npm audit report

lodash  <=4.17.20
Severity: high
Prototype Pollution in lodash - https://github.com/advisories/GHSA-fvqr-27wr-82fm
fix available via `npm audit fix --force`
Will install lodash@4.17.21, which is a breaking change
node_modules/lodash

jsonwebtoken  0.4.0
Severity: critical
jwt.verify() vulnerable to signature bypass - https://github.com/advisories/GHSA-c7hr-j4mj-j2w6
No fix available
node_modules/jsonwebtoken
  express-jwt  *
  Depends on vulnerable versions of jsonwebtoken
  node_modules/express-jwt

z-schema  <5.0.0
Severity: high
Regular Expression Denial of Service (ReDoS) - https://github.com/advisories/GHSA-qwcr-r2fm-qrc7
fix available via `npm audit fix`
node_modules/z-schema

8 vulnerabilities (3 moderate, 3 high, 2 critical)

To address all issues, run:
  npm audit fix

To address issues that require attention, run:
  npm audit fix --force


What this means:
â€¢ 8 vulnerable packages detected in dependencies
â€¢ Severity breakdown: 3 moderate, 3 high, 2 critical
â€¢ Some have automatic fixes (npm audit fix)
â€¢ Some require manual intervention (breaking changes)
â€¢ For Juice Shop: These are intentional for training purposes
â€¢ Pipeline continues (continue-on-error: true in warning mode)


================================================================================

================================================================================

STAGE 3b: RetireJS - Vulnerable JavaScript Library Detection
=============================================================

TL;DR
-----
RetireJS = Scans for known vulnerabilities in JavaScript libraries and Node.js
modules. Think of it as npm audit but for JavaScript files in your source code,
not just package.json.


Command Execution:
------------------
Run RetireJS scan with multiple output formats:

  # Install dependencies (required for node_modules scanning)
  npm install --prefer-offline --no-audit

  # Install RetireJS globally
  npm install -g retire

  # Generate JSON report (machine-readable)
  retire --path . --outputformat json --exitwith 0 > retirejs-report.json

  # Generate CycloneDX SBOM (industry standard)
  retire --path . --outputformat cyclonedx --exitwith 0 > retirejs-sbom.json

  # Generate verbose text output (human-readable)
  retire --path . --verbose --exitwith 0 > scan-output.txt

Meaning:
  â€¢ --path .           â†’ Scan current directory recursively
  â€¢ --outputformat     â†’ JSON, CycloneDX, or text format
  â€¢ --exitwith 0       â†’ Continue pipeline even if vulnerabilities found
  â€¢ --verbose          â†’ Detailed output with CVE references
  â€¢ Downloads DB       â†’ Latest vulnerability data from RetireJS GitHub repo




PURPOSE IN CI/CD PIPELINE
============================

Why RetireJS in Stage 3b?
--------------------------
âœ“ Client-side library scanning    â†’ Detects vulnerable jQuery, Angular, etc.
âœ“ Source code analysis             â†’ Finds libraries without package.json
âœ“ SBOM generation                  â†’ CycloneDX format for compliance
âœ“ Broader coverage than npm audit  â†’ Scans both installed & embedded libraries
âœ“ CVE reference tracking           â†’ Links to security advisories

Pipeline Position:
------------------
Stage 3b: RetireJS (Parallel with npm-audit, Gitleaks, Trivy, Dockerfile-policy)
             â†“
         Runs after Stage 2 (SAST, Secrets, Tests)


INTERPRETATION OF OUTPUT
==========================

Result: WARNING (vulnerable libraries found, pipeline continues)
-----------------------------------------------------------------
RetireJS scan completed with multiple report formats generated.

Typical Juice Shop Findings (intentionally vulnerable app):

Console Output:
  ğŸ“š Running RetireJS scan...
  Downloading vulnerability database from RetireJS GitHub...
  Scanning JavaScript libraries and Node.js modules...

  âœ… RetireJS scan completed
  ğŸ“Š Generated reports:
     â€¢ retirejs-report.json (JSON format)
     â€¢ retirejs-sbom.json (CycloneDX SBOM)
     â€¢ scan-output.txt (Verbose text)

Human-Readable Report Preview:
  ================================================================================
  RETIREJS VULNERABILITY SCAN REPORT
  ================================================================================

  Total Vulnerabilities: 42
    â€¢ High/Critical: 12
    â€¢ Medium: 18
    â€¢ Low/Info: 12

  ================================================================================

  [1] File: /project/node_modules/jquery/dist/jquery.js
  --------------------------------------------------------------------------------
    Component: jquery
    Version: 3.4.1
    Detection Method: filecontent

    Vulnerabilities (3):

      [1] Severity: medium
          CVE: CVE-2020-11022
          Info: https://github.com/advisories/GHSA-gxr4-xjj5-5px2

      [2] Severity: medium
          CVE: CVE-2020-11023
          Info: https://github.com/advisories/GHSA-jpcq-cgw6-v4j6

  [2] File: /project/frontend/src/assets/public/frontend.min.js
  --------------------------------------------------------------------------------
    Component: angular
    Version: 1.6.8
    Detection Method: filecontent

    Vulnerabilities (2):

      [1] Severity: high
          CVE: CVE-2019-10768
          Info: https://snyk.io/vuln/SNYK-JS-ANGULAR-534884

Scan Summary:
  ğŸ“Š RetireJS Scan Summary
  ========================
  Vulnerable libraries detected: 15


What this means:
â€¢ RetireJS found 42 vulnerabilities across 15 libraries
â€¢ Covers both client-side (jQuery, Angular) and server-side (Node modules)
â€¢ Each finding includes CVE ID and severity level
â€¢ Reports uploaded as pipeline artifacts for download
â€¢ Pipeline continues (continue-on-error: true in warning mode)
â€¢ For Juice Shop: Intentional vulnerabilities for training


COMMON RETIREJS ERRORS (What to expect if things fail)
=======================================================

If RetireJS HAD failed, you might see:

Dependency Issues:
  âœ— error  node_modules not found - run npm install first
  âœ— error  Network error downloading vulnerability database

Output Format Errors:
  âœ— error  Invalid output format specified
  âœ— error  Cannot write to output file (permissions)

Scan Issues:
  âš  warning File too large to scan: frontend/dist/bundle.js
  âš  warning Could not parse JavaScript file (syntax error)

What these mean:
  â€¢ node_modules not found: Install dependencies before running RetireJS
  â€¢ Network error: RetireJS downloads latest vuln DB from GitHub (requires internet)
  â€¢ Invalid format: Use json, cyclonedx, or text (default)
  â€¢ File too large: RetireJS may skip very large minified files

================================================================================

Key Insight: RetireJS detects vulnerable JavaScript libraries by analyzing
SOURCE CODE content (not just package.json), making it complementary to npm
audit. It finds libraries embedded in your frontend code that npm audit misses.

================================================================================

================================================================================

STAGE 3c: Gitleaks - Secret Detection in Git History
=====================================================

TL;DR
-----
Gitleaks = Scans git commit history for leaked secrets (API keys, passwords,
tokens). Think of it as a time machine that checks every commit you ever made
for accidentally committed credentials.


Command Execution:
------------------
Run Gitleaks via Docker:

  # Checkout with full git history
  git fetch --depth 0

  # Run Gitleaks secret scanner
  docker run --rm -v $(pwd):/repo \
    zricethezav/gitleaks:latest \
    detect --source /repo --verbose > gitleaks-report.txt

Meaning:
  â€¢ detect             â†’ Scan mode (checks for secrets)
  â€¢ --source /repo     â†’ Path to git repository
  â€¢ --verbose          â†’ Detailed output with finding context
  â€¢ Full history       â†’ fetch-depth: 0 scans ALL commits
  â€¢ Docker-based       â†’ No installation required




PURPOSE IN CI/CD PIPELINE
============================

Why Gitleaks in Stage 3c?
--------------------------
âœ“ Git history scanning     â†’ Checks every commit, not just current code
âœ“ Pattern-based detection  â†’ Uses 700+ secret patterns (AWS, GitHub, etc.)
âœ“ Compliance requirement   â†’ Prevent credential leaks before deployment
âœ“ Complement to TruffleHog â†’ Different detection engines, better coverage
âœ“ Fast scanning            â†’ Efficient git log analysis

Pipeline Position:
------------------
Stage 3c: Gitleaks (Parallel with npm-audit, RetireJS, Trivy, Dockerfile-policy)
             â†“
         Runs after Stage 2 (SAST, Secrets, Tests)


INTERPRETATION OF OUTPUT
==========================

Result: SUCCESS (no secrets found, or warning mode if found)
------------------------------------------------------------
Gitleaks scans git history for leaked credentials.

Typical Output (Clean Scan):
  ğŸ” Running Gitleaks secret scan...

      â—‹
      â”‚â•²
      â”‚ â—‹
      â—‹ â–‘
      â–‘    gitleaks

  No leaks found! âœ…

What this means:
â€¢ No secrets detected in any git commits
â€¢ Repository history is clean
â€¢ Safe to proceed with deployment

Typical Output (Secrets Found - Training App):
  ğŸ” Running Gitleaks secret scan...

  Finding: generic-api-key
  Secret: sk_live_1234567890abcdef...
  File: config/database.js
  Line: 23
  Commit: a1b2c3d (2024-01-15)
  Author: developer@example.com
  Date: 2024-01-15 10:30:00

  Finding: aws-access-token
  Secret: AKIA****************
  File: .env.backup
  Line: 5
  Commit: e4f5g6h (2024-01-10)

  8:40PM INF 2 leaks detected
  âš ï¸  Secrets found (warning mode)

What this means:
â€¢ 2 secrets found in git commit history
â€¢ Even deleted files are checked (git remembers everything)
â€¢ Shows exact commit, file, line where secret was added
â€¢ Pipeline continues (continue-on-error: true)
â€¢ For Juice Shop: May find intentional test credentials


COMMON GITLEAKS ERRORS (What to expect if things fail)
=======================================================

If Gitleaks HAD failed, you might see:

Docker/Setup Issues:
  âœ— error  Failed to pull Docker image
  âœ— error  Permission denied: /repo directory

Git History Issues:
  âœ— error  Not a git repository
  âœ— error  Shallow clone detected (fetch-depth too small)

Configuration Issues:
  âœ— error  Invalid .gitleaks.toml configuration
  âš  warning Custom rules failed to compile

What these mean:
  â€¢ Docker pull failed: Check network or Docker Hub access
  â€¢ Not a git repo: Ensure .git directory exists
  â€¢ Shallow clone: Use fetch-depth: 0 to scan full history
  â€¢ Invalid config: Check .gitleaks.toml syntax if using custom rules

================================================================================

Key Insight: Gitleaks scans ENTIRE git history (not just working directory),
finding secrets in old commits, deleted files, and even reverted changes. This
is why fetch-depth: 0 is critical - shallow clones miss historical leaks.

Gitleaks vs TruffleHog - Key Differences
=========================================

  | Aspect             | Gitleaks                    | TruffleHog                  |
  |--------------------|-----------------------------|-----------------------------|
  | Detection Method   | Pattern-based (regex)       | Pattern + verification      |
  | Secret Patterns    | 700+ built-in rules         | 800+ detectors              |
  | Verification       | âŒ No live verification     | âœ… Verifies with services   |
  | Speed              | Very fast (regex only)      | Slower (verification calls) |
  | False Positives    | Higher (no verification)    | Lower (verified secrets)    |
  | Scan Scope         | Git history + files         | Git history + files         |
  | Output Detail      | Commit, file, line          | + validity status           |
  | Use Case           | Quick historical scan       | Deep verified scan          |

When to use each:
  â€¢ Gitleaks    â†’ Fast pattern matching, broad coverage
  â€¢ TruffleHog  â†’ Verification needed, active credentials only

Both run in parallel (Stage 2b: TruffleHog, Stage 3c: Gitleaks) for maximum
coverage - pattern detection + verification = comprehensive secret scanning.

================================================================================

================================================================================

STAGE 3d: Trivy - Container Security Scanner
=============================================

TL;DR
-----
Trivy = Scans Docker images for OS vulnerabilities, misconfigurations, and
security issues in base images. Think of it as a security X-ray for your
container - checking every layer for known vulnerabilities.


Command Execution:
------------------
Run Trivy via Docker to scan the BUILT image (not building again):

  # Load the built image from previous stage
  docker load -i juice-shop-image.tar

  # Scan for HIGH severity vulnerabilities
  docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    -v $HOME/.cache:/root/.cache/ \
    aquasec/trivy:latest image --exit-code 0 --severity HIGH --light juice-shop:latest

  # Scan for CRITICAL severity vulnerabilities
  docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    -v $HOME/.cache:/root/.cache/ \
    aquasec/trivy:latest image --exit-code 0 --severity CRITICAL --light juice-shop:latest

Meaning:
  â€¢ image                â†’ Scan Docker image (not filesystem)
  â€¢ --severity HIGH      â†’ Filter to show HIGH severity vulns
  â€¢ --severity CRITICAL  â†’ Filter to show CRITICAL severity vulns
  â€¢ --exit-code 0        â†’ Continue pipeline even if vulns found
  â€¢ --light              â†’ Faster scan (skip Java archives)
  â€¢ Docker sock mount    â†’ Access to Docker daemon for image inspection
  â€¢ Cache mount          â†’ Reuse vulnerability database across runs




PURPOSE IN CI/CD PIPELINE
============================

Why Trivy in Stage 3d?
-----------------------
âœ“ Container-specific scanning  â†’ Detects base image vulnerabilities
âœ“ OS package vulnerabilities   â†’ Checks Alpine, Debian, Ubuntu packages
âœ“ Layer-by-layer analysis      â†’ Identifies which layer introduced vuln
âœ“ Fast and comprehensive       â†’ Scans complete image in seconds
âœ“ No image push required       â†’ Scans locally built images
âœ“ Shift-left security          â†’ Catch container issues before deployment

Pipeline Position:
------------------
Stage 5b: Trivy (Security Gate between Build and Push)
             â†“
         Runs after Stage 5 (Build & Tag Docker Image)
         Runs before Stage 6 (Push to Docker Hub)


INTERPRETATION OF OUTPUT
==========================

Result: WARNING (vulnerabilities found, pipeline continues)
-----------------------------------------------------------
Trivy scans Docker image layers for OS and application vulnerabilities.

Typical Output (Juice Shop Container):
  ğŸ³ Running Trivy container scan...
  Building image for scanning...

  === Trivy Scan - HIGH Severity (Warning) ===

  juice-shop:scan (alpine 3.19.1)
  ===============================
  Total: 12 (HIGH: 12)

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Library     â”‚ Vulnerabilityâ”‚ Severity â”‚ Installed Ver â”‚  Fixed Ver    â”‚          Title             â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ libcrypto3    â”‚ CVE-2024-0727â”‚   HIGH   â”‚  3.1.4-r5     â”‚  3.1.4-r6     â”‚ openssl: denial of service â”‚
  â”‚               â”‚              â”‚          â”‚               â”‚               â”‚ via null dereference       â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ libssl3       â”‚ CVE-2024-0727â”‚   HIGH   â”‚  3.1.4-r5     â”‚  3.1.4-r6     â”‚ openssl: denial of service â”‚
  â”‚               â”‚              â”‚          â”‚               â”‚               â”‚ via null dereference       â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ zlib          â”‚ CVE-2023-6992â”‚   HIGH   â”‚  1.3.1-r0     â”‚  1.3.1-r1     â”‚ zlib: buffer overflow      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


  === Trivy Scan - CRITICAL Severity ===

  juice-shop:scan (alpine 3.19.1)
  ===============================
  Total: 3 (CRITICAL: 3)

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Library     â”‚ Vulnerabilityâ”‚ Severity â”‚ Installed Ver â”‚  Fixed Ver    â”‚          Title             â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ curl          â”‚ CVE-2024-2398â”‚ CRITICAL â”‚  8.5.0-r0     â”‚  8.7.1-r0     â”‚ curl: TELNET option IAC    â”‚
  â”‚               â”‚              â”‚          â”‚               â”‚               â”‚ injection                  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ğŸ“Š Trivy scan completed
  âš ï¸  HIGH severity vulnerabilities found
  âš ï¸  CRITICAL vulnerabilities found (warning mode for training)

What this means:
â€¢ 12 HIGH + 3 CRITICAL vulnerabilities in base image OS packages
â€¢ Vulnerabilities in system libraries (OpenSSL, zlib, curl)
â€¢ Shows installed version vs fixed version for remediation
â€¢ Pipeline continues (continue-on-error: true, warning mode)
â€¢ Fix: Update base image or rebuild with patched OS packages



================================================================================

Key Insight: Trivy scans CONTAINER LAYERS for OS package vulnerabilities,
identifying exactly which Dockerfile layer introduced each vulnerability. Unlike
npm audit (app dependencies) or CodeQL (code), Trivy focuses on the container
runtime environment - base images, system libraries, and OS packages.


================================================================================

================================================================================

STAGE 3d: Dockerfile Policy Validation (OPA/Conftest)
======================================================

TL;DR
-----
OPA/Conftest = Policy-as-Code tool that validates Dockerfile against security
best practices. Think of it as a security checklist enforcer that prevents
insecure container configurations before build.


Command Execution:
------------------
Run Conftest via Docker with custom OPA policy:

  # Pull Conftest Docker image
  docker pull openpolicyagent/conftest:latest

  # Test Dockerfile against comprehensive security policy
  docker run --rm -v $(pwd):/project \
    openpolicyagent/conftest:latest \
    test --policy ./docs/docker/dockerfile-security.rego Dockerfile

Meaning:
  â€¢ test                  â†’ Validation mode (checks against policies)
  â€¢ --policy <path>       â†’ Path to OPA Rego policy file
  â€¢ Dockerfile            â†’ Target file to validate
  â€¢ Docker-based          â†’ No installation required
  â€¢ Policy-as-Code        â†’ Declarative security rules in Rego language




PURPOSE IN CI/CD PIPELINE
============================

Why OPA/Conftest in Stage 3d?
------------------------------
âœ“ Shift-left security           â†’ Catch misconfigurations before build
âœ“ Enforce best practices        â†’ Automated Dockerfile security standards
âœ“ Policy-as-Code                â†’ Version-controlled security rules
âœ“ Fast validation               â†’ Runs in seconds (static analysis)
âœ“ No image build required       â†’ Validates Dockerfile syntax only
âœ“ Prevent configuration drift   â†’ Consistent security across all images

Pipeline Position:
------------------
Stage 3d: Dockerfile Policy (Parallel with npm-audit, RetireJS, Gitleaks)
             â†“
         Runs after Stage 2 (SAST, Secrets, Tests)


INTERPRETATION OF OUTPUT
==========================

Result: FAILURE (policy violations found, warning mode continues)
------------------------------------------------------------------
Conftest validates Dockerfile against 9 comprehensive security policies.

Security Policies Enforced:
  âœ“ No secrets in ENV variables
  âœ“ Use trusted base images only
  âœ“ No 'latest' tag for base images
  âœ“ Avoid curl bashing
  âœ“ No system package upgrades in Dockerfile
  âœ“ Use COPY instead of ADD
  âœ“ Don't run as root user
  âœ“ Don't use sudo command
  âœ“ Use multi-stage builds

Typical Juice Shop Findings (intentionally insecure Dockerfile):

Console Output:
  ğŸ“‹ Running OPA/Conftest policy validation...
  ğŸ” Testing Dockerfile against comprehensive security policies...

  FAIL - Dockerfile - main - Do not run as root, use USER instead
  WARN - Dockerfile - main - Line: 15: Do not upgrade your system packages: run npm install
  FAIL - Dockerfile - main - You COPY, but do not appear to use multi-stage builds...

  3 tests, 0 passed, 1 warning, 2 failures

  âš ï¸  Policy violations found (exit code: 1)
  ğŸ“ This is expected for training - Juice Shop is intentionally vulnerable
  ğŸ“š Reference: https://cloudberry.engineering/article/dockerfile-security-best-practices/
  âœ… Pipeline continues in warning mode

Policy Violations Explained:

âœ— FAIL: Do not run as root, use USER instead
  Issue: No USER directive specified in Dockerfile
  Risk: Container runs as root (UID 0), full system privileges
  Fix: Add "USER node" or "USER 1000:1000" before CMD

âœ— FAIL: You COPY, but do not appear to use multi-stage builds
  Issue: Single-stage build detected
  Risk: Includes build tools in final image (larger attack surface)
  Fix: Use multi-stage builds with "COPY --from=builder"

âš  WARN: Do not upgrade your system packages
  Issue: Dockerfile runs "npm install" (package manager)
  Risk: Non-deterministic builds, unexpected package versions
  Fix: Pin all package versions in package-lock.json

What this means:
â€¢ 2 failures, 1 warning detected in Dockerfile configuration
â€¢ Root user violation is high security risk
â€¢ Missing multi-stage builds increases image size and attack surface
â€¢ Pipeline continues (continue-on-error: true for training)
â€¢ For Juice Shop: Intentional policy violations for demonstration


================================================================================

Key Insight: OPA/Conftest validates Dockerfile CONFIGURATION (not built images),
catching misconfigurations BEFORE build stage. It's complementary to Trivy:
Conftest checks Dockerfile syntax/policies, Trivy scans built image vulnerabilities.

OPA/Conftest vs Trivy - Key Differences
========================================

  | Aspect            | OPA/Conftest            | Trivy                      |
  |-------------------|-------------------------|----------------------------|
  | Scan Target       | Dockerfile text         | Built Docker image         |
  | Analysis Type     | Policy-as-Code          | Vulnerability database     |
  | Focus             | Configuration security  | OS package vulnerabilities |
  | When It Runs      | Before build            | After build                |
  | Speed             | Very fast (<1 sec)      | Fast (5-10 sec)            |
  | Detects           | Policy violations       | Known CVEs                 |
  | Customizable      | âœ… Custom Rego policies | âš ï¸  Limited (severity)     |
  | False Positives   | Low (deterministic)     | Low (CVE database)         |

When to use each:
  â€¢ Conftest   â†’ Prevent bad Dockerfile patterns (policy enforcement)
  â€¢ Trivy      â†’ Detect vulnerable packages in built images (CVE scanning)

Both run in the pipeline for defense-in-depth:
  Stage 3d: Conftest (validate Dockerfile policies)
  Stage 5b: Trivy (scan built image for CVEs)

================================================================================


================================================================================

================================================================================

STAGE 8a: K8s Manifest Security Scanning
=========================================

TL;DR
-----
K8s Manifest Security = Policy-based validation of Kubernetes YAML files for
security misconfigurations. Think of it as a pre-deployment security checklist
that catches insecure K8s configs before they reach the cluster.


Command Execution:
------------------
Run Conftest via Docker against K8s manifests:

  # Scan Deployment manifest
  docker run --rm -v $(pwd):/project \
    openpolicyagent/conftest:latest \
    test --policy ./policy kind-k8s-cluster/juice-shop-deployment.yaml

  # Scan Service manifest
  docker run --rm -v $(pwd):/project \
    openpolicyagent/conftest:latest \
    test --policy ./policy kind-k8s-cluster/juice-shop-service.yaml

Meaning:
  â€¢ test                  â†’ Validation mode (checks against policies)
  â€¢ --policy ./policy     â†’ Path to OPA Rego policy directory
  â€¢ <manifest.yaml>       â†’ K8s YAML files to validate
  â€¢ Docker-based          â†’ No installation required
  â€¢ Policy-as-Code        â†’ Declarative security rules in Rego




PURPOSE IN CI/CD PIPELINE
============================

Why K8s Manifest Security in Stage 8a?
---------------------------------------
âœ“ Pre-deployment validation   â†’ Catch misconfigurations before apply
âœ“ Enforce security standards  â†’ Automated K8s best practices
âœ“ Prevent privilege escalation â†’ Check runAsNonRoot, securityContext
âœ“ Resource governance         â†’ Verify resource limits and requests
âœ“ Service exposure control    â†’ Validate service type configurations
âœ“ Fast feedback loop          â†’ Fails before cluster deployment

Pipeline Position:
------------------
Stage 8a: K8s Manifest Security (Parallel with OWASP ZAP, Security Headers, Noir)
             â†“
         Runs after Stage 7 (Deploy to Kubernetes)
         Runs in parallel with DAST tools


INTERPRETATION OF OUTPUT
==========================

Result: WARNING (policy violations found, deployment continues)
----------------------------------------------------------------
Conftest validates K8s manifests against security best practices.

Security Policies Checked:
  â€¢ Containers running as non-root (runAsNonRoot)
  â€¢ Security context settings
  â€¢ Service type configurations
  â€¢ Resource limits and requests

Typical Juice Shop Findings (intentionally insecure manifests):

Console Output:
  ğŸ” Scanning Kubernetes manifests for security issues...

  === Scanning K8s Deployment Manifest ===
  FAIL - kind-k8s-cluster/juice-shop-deployment.yaml - main - Container 'juice-shop'
         does not set securityContext.runAsNonRoot
  FAIL - kind-k8s-cluster/juice-shop-deployment.yaml - main - Container 'juice-shop'
         does not set securityContext.allowPrivilegeEscalation=false
  WARN - kind-k8s-cluster/juice-shop-deployment.yaml - main - No resource limits defined
         (could impact cluster stability)

  3 tests, 0 passed, 1 warning, 2 failures
  âš ï¸  Policy violations in deployment manifest

  === Scanning K8s Service Manifest ===
  FAIL - kind-k8s-cluster/juice-shop-service.yaml - main - Service uses LoadBalancer
         type (exposes publicly, consider NodePort or ClusterIP)

  1 test, 0 passed, 0 warnings, 1 failure
  âš ï¸  Policy violations in service manifest

  ğŸ“ K8s manifest scan checks for:
     - Containers running as non-root (runAsNonRoot)
     - Security context settings
     - Service type configurations
     - Resource limits and requests
  ğŸ“š Reference: Best practices from DevSecOps patterns

Policy Violations Explained:

âœ— FAIL: Container does not set runAsNonRoot
  Issue: No securityContext.runAsNonRoot specified
  Risk: Pod can run as root (UID 0) with elevated privileges
  Fix: Add to deployment spec:
       securityContext:
         runAsNonRoot: true
         runAsUser: 1000

âœ— FAIL: allowPrivilegeEscalation not set to false
  Issue: Container can gain more privileges than parent
  Risk: Privilege escalation attacks possible
  Fix: Add to container securityContext:
       securityContext:
         allowPrivilegeEscalation: false

âœ— FAIL: Service uses LoadBalancer type
  Issue: Service exposes publicly via cloud load balancer
  Risk: Direct internet exposure without proper controls
  Fix: Use NodePort or ClusterIP with Ingress controller

What this means:
â€¢ Multiple security misconfigurations in K8s manifests
â€¢ Containers running without security restrictions
â€¢ Public service exposure without proper controls
â€¢ Pipeline continues (continue-on-error: true for training)
â€¢ For Juice Shop: Intentional misconfigurations for demonstration



================================================================================

Key Insight: K8s Manifest Security scans YAML CONFIGURATION files (not running
pods), catching security misconfigurations BEFORE deployment. It's complementary
to runtime security tools: Conftest validates manifests, runtime tools monitor
actual pod behavior. Defense-in-depth: validate configs (Stage 8a) â†’ deploy
(Stage 7) â†’ scan runtime (DAST in Stage 8b-d).

K8s Manifest Security vs Container Scanning - Key Differences
==============================================================

  | Aspect            | K8s Manifest Scan       | Container Scan (Trivy)     |
  |-------------------|-------------------------|----------------------------|
  | Scan Target       | K8s YAML files          | Docker images              |
  | Analysis Type     | Policy-as-Code          | Vulnerability database     |
  | Focus             | Deployment security     | Image vulnerabilities      |
  | When It Runs      | Before/after deployment | After image build          |
  | Speed             | Very fast (<2 sec)      | Fast (5-10 sec)            |
  | Detects           | Misconfigurations       | Known CVEs                 |
  | Examples          | runAsNonRoot, resources | OS package vulnerabilities |
  | Scope             | K8s orchestration layer | Container image layer      |

When to use each:
  â€¢ K8s Manifest   â†’ Prevent insecure K8s configurations (policy enforcement)
  â€¢ Trivy          â†’ Detect vulnerable packages in images (CVE scanning)

Both run in the pipeline for defense-in-depth:
  Stage 5b: Trivy (scan built Docker image for CVEs)
  Stage 8a: K8s Manifest (validate K8s deployment configs)

================================================================================


