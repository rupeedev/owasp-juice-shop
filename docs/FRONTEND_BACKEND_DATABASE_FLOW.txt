================================================================================
OWASP JUICE SHOP - FRONTEND, BACKEND API & DATABASE FLOW
================================================================================

This document describes the complete flow of data and interactions between
the Frontend (Angular), Backend (Express/Node.js), and Database (SQLite)
components of the OWASP Juice Shop application.

================================================================================
ARCHITECTURE OVERVIEW
================================================================================

┌─────────────────────────────────────────────────────────────────────────┐
│                          CLIENT BROWSER                                  │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    ANGULAR FRONTEND (Port 4200 dev / 3000 prod)   │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐            │  │
│  │  │  Components  │  │   Services   │  │    Guards    │            │  │
│  │  │  (Views/UI)  │  │  (HTTP API)  │  │    (Auth)    │            │  │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘            │  │
│  │         │                 │                 │                      │  │
│  │         └─────────────────┴─────────────────┘                      │  │
│  │                           │                                         │  │
│  └───────────────────────────┼─────────────────────────────────────────┘  │
└───────────────────────────────┼─────────────────────────────────────────┘
                                │ HTTP/HTTPS Requests (REST API)
                                │ (JSON payloads)
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    EXPRESS.JS BACKEND SERVER (Port 3000)                │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                        server.ts (Main Entry)                     │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐            │  │
│  │  │ Middleware   │  │   Routes     │  │    lib/      │            │  │
│  │  │ (Auth, CORS, │  │ (API Logic)  │  │  (Utilities) │            │  │
│  │  │  Security)   │  │              │  │              │            │  │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘            │  │
│  │         │                 │                 │                      │  │
│  │         └─────────────────┴─────────────────┘                      │  │
│  │                           │                                         │  │
│  └───────────────────────────┼─────────────────────────────────────────┘  │
└───────────────────────────────┼─────────────────────────────────────────┘
                                │ Sequelize ORM
                                │ (SQL Queries)
                                ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    SQLITE DATABASE (data/juiceshop.sqlite)              │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  Tables: Users, Products, Baskets, BasketItems, Feedback,        │  │
│  │          Challenges, SecurityQuestions, SecurityAnswers, etc.     │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘

================================================================================
1. APPLICATION STARTUP FLOW
================================================================================

1.1 Backend Initialization (server.ts)
---------------------------------------
   a) Load environment configuration (config package)
   b) Initialize database connection (Sequelize)
      → models/index.ts creates Sequelize instance
      → Points to data/juiceshop.sqlite
   c) Initialize all 20+ models (User, Product, Basket, etc.)
      → models/*.ts define schema and relationships
   d) Run database sync (sequelize.sync())
   e) Populate initial data (data/datacreator.ts)
      → Load products from data/static/products.json
      → Create default users, challenges, etc.
   f) Set up Express middleware stack:
      → CORS (cors)
      → Body parser (body-parser)
      → Cookie parser (cookie-parser)
      → Authentication (express-jwt)
      → Security headers (helmet, feature-policy)
      → Rate limiting (express-rate-limit)
      → Static file serving (express.static)
   g) Register API routes (routes/*.ts)
   h) Initialize finale-rest (auto-generate CRUD endpoints)
   i) Start HTTP server on port 3000

1.2 Frontend Initialization (Angular)
--------------------------------------
   a) Bootstrap Angular application (main.ts)
   b) Load root module (AppModule)
   c) Initialize routing (AppRoutingModule)
   d) Configure HTTP interceptors for:
      → JWT token attachment
      → Error handling
   e) Render initial component (AppComponent)
   f) Angular serves static files in production from frontend/dist/
   g) In development, Angular dev server runs on port 4200

================================================================================
2. REQUEST/RESPONSE FLOW - TYPICAL USER JOURNEY
================================================================================

2.1 User Visits Homepage
------------------------
   Browser → GET http://localhost:3000
           ↓
   [Express Backend]
           ↓
   Serves → frontend/dist/frontend/index.html
           ↓
   [Angular App Loads]
           ↓
   Angular Router → Loads HomeComponent
           ↓
   Component → Calls ProductService.getProducts()
           ↓
   HTTP GET → /api/Products
           ↓
   [Backend Route: auto-generated by finale-rest]
           ↓
   [Sequelize ORM]
           ↓
   SQL: SELECT * FROM Products WHERE deletedAt IS NULL
           ↓
   [SQLite Database]
           ↓
   Returns product rows
           ↓
   [Backend] → JSON response: { status: 'success', data: [...products] }
           ↓
   [Frontend ProductService] → Receives Observable<Product[]>
           ↓
   [HomeComponent] → Displays products in UI grid

2.2 User Registration Flow
---------------------------
   [Frontend RegisterComponent]
           ↓
   User fills form (email, password, security question, answer)
           ↓
   Form Submit → UserService.register(userData)
           ↓
   HTTP POST → /api/Users
           ↓
   Body: {
     email: 'user@example.com',
     password: 'password123',
     passwordRepeat: 'password123',
     securityQuestion: { id: 1 },
     securityAnswer: 'answer'
   }
           ↓
   [Backend Route: routes/user.ts or auto-generated]
           ↓
   Validation:
     - Email format
     - Password strength (intentionally weak for vulnerabilities)
     - Security answer
           ↓
   Hash password (lib/insecurity.ts - intentionally weak MD5)
           ↓
   [Sequelize - UserModel.create()]
           ↓
   SQL: INSERT INTO Users (email, password, role, createdAt, updatedAt)
        VALUES (?, ?, 'customer', NOW(), NOW())
           ↓
   [SQLite Database] → Creates new user record
           ↓
   Also creates:
     - SecurityAnswer record (INSERT INTO SecurityAnswers)
     - Basket record (INSERT INTO Baskets)
           ↓
   [Backend] → Returns JSON:
           {
             status: 'success',
             data: {
               id: 123,
               email: 'user@example.com',
               role: 'customer',
               token: 'JWT_TOKEN_HERE'
             }
           }
           ↓
   [Frontend UserService]
           ↓
   Store token in localStorage/sessionStorage
           ↓
   Navigate to /login or /profile

2.3 User Login Flow
--------------------
   [Frontend LoginComponent]
           ↓
   User enters email + password
           ↓
   Form Submit → UserService.login(credentials)
           ↓
   HTTP POST → /rest/user/login
           ↓
   Body: { email: 'user@example.com', password: 'password123' }
           ↓
   [Backend Route: routes/login.ts]
           ↓
   [Sequelize - UserModel.findOne()]
           ↓
   SQL: SELECT * FROM Users WHERE email = ? AND deletedAt IS NULL
           ↓
   [SQLite] → Returns user record
           ↓
   Verify password:
     - Hash input password (MD5)
     - Compare with stored hash
           ↓
   If valid:
     - Generate JWT token (lib/insecurity.ts)
     - Token contains: { data: { id, email, role } }
     - Sign with SECRET_KEY (intentionally weak)
           ↓
   [Backend] → Returns JSON:
           {
             authentication: {
               token: 'eyJhbGc...',
               bid: basketId,
               umail: 'user@example.com'
             }
           }
           ↓
   [Frontend UserService]
           ↓
   Store token in localStorage
           ↓
   Set Authorization header for future requests
           ↓
   Redirect to homepage

2.4 Adding Product to Basket Flow
----------------------------------
   [Frontend BasketComponent]
           ↓
   User clicks "Add to Basket" on product
           ↓
   BasketService.addToBasket(productId, quantity)
           ↓
   HTTP POST → /api/BasketItems
           ↓
   Headers: { Authorization: 'Bearer JWT_TOKEN' }
           ↓
   Body: {
     ProductId: 5,
     BasketId: 123,
     quantity: 2
   }
           ↓
   [Backend Middleware: express-jwt]
           ↓
   Verify JWT token → Extract user info
           ↓
   [Backend Route: routes/basketItems.ts or auto-generated]
           ↓
   Validation:
     - Check product exists
     - Check basket belongs to authenticated user
     - Validate quantity
           ↓
   [Sequelize - BasketItemModel.create() or update()]
           ↓
   Check if item already in basket:
   SQL: SELECT * FROM BasketItems
        WHERE BasketId = ? AND ProductId = ?
           ↓
   If exists:
     SQL: UPDATE BasketItems
          SET quantity = quantity + ?
          WHERE id = ?
   Else:
     SQL: INSERT INTO BasketItems
          (BasketId, ProductId, quantity, createdAt, updatedAt)
          VALUES (?, ?, ?, NOW(), NOW())
           ↓
   [SQLite] → Creates/updates basket item record
           ↓
   [Backend] → Returns JSON:
           {
             status: 'success',
             data: {
               id: 456,
               BasketId: 123,
               ProductId: 5,
               quantity: 2,
               Product: { name: 'Apple Juice', price: 1.99 }
             }
           }
           ↓
   [Frontend BasketService]
           ↓
   Update basket count in UI
           ↓
   Show success notification

2.5 Search Products Flow
-------------------------
   [Frontend SearchComponent]
           ↓
   User types in search box
           ↓
   Debounced HTTP GET → /rest/products/search?q=apple
           ↓
   [Backend Route: routes/search.ts]
           ↓
   [Sequelize - ProductModel.findAll()]
           ↓
   SQL: SELECT * FROM Products
        WHERE name LIKE '%apple%'
        OR description LIKE '%apple%'
        AND deletedAt IS NULL
   (Note: Intentionally vulnerable to SQL injection)
           ↓
   [SQLite] → Returns matching products
           ↓
   [Backend] → Returns JSON:
           {
             status: 'success',
             data: [
               { id: 1, name: 'Apple Juice', ... },
               { id: 5, name: 'Apple Pomace', ... }
             ]
           }
           ↓
   [Frontend SearchComponent]
           ↓
   Display search results

2.6 Submit Feedback Flow
-------------------------
   [Frontend ContactComponent]
           ↓
   User fills feedback form (comment, rating, captcha)
           ↓
   HTTP POST → /api/Feedbacks
           ↓
   Body: {
     comment: 'Great product!',
     rating: 5,
     captchaId: 123,
     captcha: '5'
   }
           ↓
   [Backend Route: routes/feedback.ts]
           ↓
   Verify captcha:
     SQL: SELECT * FROM Captchas WHERE id = ? AND answer = ?
           ↓
   [Sequelize - FeedbackModel.create()]
           ↓
   SQL: INSERT INTO Feedbacks
        (comment, rating, UserId, createdAt, updatedAt)
        VALUES (?, ?, ?, NOW(), NOW())
           ↓
   [SQLite] → Creates feedback record
           ↓
   Check for challenge completion (lib/challengeUtils.ts)
           ↓
   [Backend] → Returns JSON:
           {
             status: 'success',
             data: { id: 789, comment: '...', rating: 5 }
           }

================================================================================
3. AUTHENTICATION & AUTHORIZATION FLOW
================================================================================

3.1 JWT Token Flow
------------------
   Login Success
           ↓
   Backend generates JWT: jsonwebtoken.sign({ data: userData }, SECRET)
           ↓
   Frontend stores token: localStorage.setItem('token', jwt)
           ↓
   Subsequent API requests include header:
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
           ↓
   [Backend Middleware: express-jwt]
           ↓
   Verify token signature
           ↓
   Decode payload → req.user = { id, email, role }
           ↓
   Route handler has access to authenticated user info

3.2 Authorization Checks
------------------------
   Request → /api/Users/:id
           ↓
   [express-jwt middleware] → Verify token
           ↓
   [Route handler]
           ↓
   Check: req.user.id === req.params.id OR req.user.role === 'admin'
           ↓
   If authorized → Process request
   If not → Return 401 Unauthorized

================================================================================
4. DATABASE LAYER (SEQUELIZE ORM)
================================================================================

4.1 Model Definition Example (models/user.ts)
----------------------------------------------
   export const UserModelInit = (sequelize: Sequelize) => {
     User.init({
       id: { type: DataTypes.INTEGER, primaryKey: true },
       email: { type: DataTypes.STRING, unique: true },
       password: { type: DataTypes.STRING },
       role: { type: DataTypes.STRING, defaultValue: 'customer' },
       ...
     }, { sequelize, tableName: 'Users', paranoid: true })
   }

4.2 Model Relationships (models/relations.ts)
----------------------------------------------
   User.hasOne(Basket)
   Basket.belongsTo(User)

   Basket.hasMany(BasketItem)
   BasketItem.belongsTo(Basket)

   Product.hasMany(BasketItem)
   BasketItem.belongsTo(Product)

   User.hasMany(Feedback)
   Feedback.belongsTo(User)

4.3 Query Examples
------------------
   // Find all products
   ProductModel.findAll({ where: { deletedAt: null } })
   → SELECT * FROM Products WHERE deletedAt IS NULL

   // Find user with associations
   UserModel.findOne({
     where: { id: userId },
     include: [Basket, Feedback]
   })
   → SELECT * FROM Users WHERE id = ?
   → SELECT * FROM Baskets WHERE UserId = ?
   → SELECT * FROM Feedbacks WHERE UserId = ?

   // Create with association
   BasketItemModel.create({
     BasketId: 123,
     ProductId: 5,
     quantity: 2
   })
   → INSERT INTO BasketItems (...) VALUES (...)

================================================================================
5. API ENDPOINT PATTERNS
================================================================================

5.1 Auto-Generated REST Endpoints (via finale-rest)
----------------------------------------------------
   GET    /api/Products           → List all products
   GET    /api/Products/:id       → Get single product
   POST   /api/Products           → Create product (admin only)
   PUT    /api/Products/:id       → Update product (admin only)
   DELETE /api/Products/:id       → Delete product (admin only)

   Similar patterns for:
   - /api/Users
   - /api/Baskets
   - /api/BasketItems
   - /api/Feedbacks
   - /api/Challenges
   - etc.

5.2 Custom Routes (in routes/)
-------------------------------
   POST   /rest/user/login         → User authentication
   POST   /rest/user/change-password → Change password
   GET    /rest/products/search    → Search products
   POST   /api/Feedbacks           → Submit feedback
   GET    /api/Challenges          → Get all challenges
   POST   /rest/user/reset-password → Password reset
   GET    /rest/admin/application-version → Get app version
   POST   /rest/basket/:id/checkout → Checkout basket

================================================================================
6. FRONTEND SERVICE LAYER
================================================================================

6.1 Service Structure (frontend/src/app/)
------------------------------------------
   services/
   ├── user.service.ts          → User authentication, profile
   ├── product.service.ts       → Product listing, search
   ├── basket.service.ts        → Shopping cart operations
   ├── feedback.service.ts      → Feedback submission
   ├── challenge.service.ts     → Challenge tracking
   └── configuration.service.ts → App configuration

6.2 HTTP Service Example (product.service.ts)
----------------------------------------------
   @Injectable()
   export class ProductService {
     constructor(private http: HttpClient) {}

     getProducts(): Observable<Product[]> {
       return this.http.get<any>('/api/Products')
         .pipe(map(response => response.data))
     }

     searchProducts(query: string): Observable<Product[]> {
       return this.http.get<any>(`/rest/products/search?q=${query}`)
         .pipe(map(response => response.data))
     }
   }

6.3 Component Usage Example
----------------------------
   export class ProductListComponent implements OnInit {
     products: Product[] = []

     constructor(private productService: ProductService) {}

     ngOnInit() {
       this.productService.getProducts()
         .subscribe(products => this.products = products)
     }
   }

================================================================================
7. ERROR HANDLING FLOW
================================================================================

7.1 Backend Error Handling
---------------------------
   Route Handler Error
           ↓
   Try-Catch Block
           ↓
   Log error (console.error or winston)
           ↓
   Return appropriate HTTP status:
     - 400 Bad Request (validation errors)
     - 401 Unauthorized (auth failures)
     - 403 Forbidden (insufficient permissions)
     - 404 Not Found (resource not exists)
     - 500 Internal Server Error (unexpected errors)
           ↓
   JSON Response: { error: 'Error message', status: 'error' }

7.2 Frontend Error Handling
----------------------------
   HTTP Request
           ↓
   [HTTP Interceptor]
           ↓
   Catch HTTP errors
           ↓
   Check status code:
     - 401 → Redirect to login, clear token
     - 403 → Show "Access Denied" message
     - 404 → Show "Not Found" message
     - 500 → Show "Server Error" message
           ↓
   Display error to user via:
     - MatSnackBar (Material Design toast)
     - Error component
     - Console log

================================================================================
8. SECURITY CONSIDERATIONS (Intentional Vulnerabilities)
================================================================================

⚠️  IMPORTANT: These are INTENTIONAL vulnerabilities for educational purposes!

8.1 Authentication Weaknesses
------------------------------
   - Weak password hashing (MD5 instead of bcrypt)
   - Predictable JWT secret keys
   - No rate limiting on login attempts (in some configurations)
   - Session tokens don't expire properly

8.2 SQL Injection
-----------------
   - Search endpoint vulnerable: /rest/products/search?q=...
   - Direct string concatenation in SQL queries (intentional)

8.3 XSS (Cross-Site Scripting)
-------------------------------
   - Unsanitized user input in feedback
   - Angular's sanitizer bypassed in some places

8.4 Broken Access Control
--------------------------
   - Insecure Direct Object References (IDOR)
   - Users can access other users' data by changing IDs
   - Admin endpoints accessible with manipulated tokens

8.5 API Security Issues
-----------------------
   - Mass assignment vulnerabilities
   - No input validation in many endpoints
   - Response contains sensitive data

================================================================================
9. DATA FLOW SUMMARY
================================================================================

┌─────────────┐
│   Browser   │
└──────┬──────┘
       │ 1. User Action (click, submit form)
       ▼
┌──────────────────────┐
│ Angular Component    │
│ (UI Logic)           │
└──────┬───────────────┘
       │ 2. Call Service Method
       ▼
┌──────────────────────┐
│ Angular Service      │
│ (HTTP Client)        │
└──────┬───────────────┘
       │ 3. HTTP Request (GET/POST/PUT/DELETE)
       ▼
┌──────────────────────┐
│ Express Middleware   │
│ (Auth, Validation)   │
└──────┬───────────────┘
       │ 4. Verified Request
       ▼
┌──────────────────────┐
│ Route Handler        │
│ (Business Logic)     │
└──────┬───────────────┘
       │ 5. Database Operation
       ▼
┌──────────────────────┐
│ Sequelize ORM        │
│ (Query Builder)      │
└──────┬───────────────┘
       │ 6. SQL Query
       ▼
┌──────────────────────┐
│ SQLite Database      │
│ (Data Storage)       │
└──────┬───────────────┘
       │ 7. Query Result
       ▼
┌──────────────────────┐
│ Sequelize ORM        │
│ (Map to Models)      │
└──────┬───────────────┘
       │ 8. JavaScript Objects
       ▼
┌──────────────────────┐
│ Route Handler        │
│ (Format Response)    │
└──────┬───────────────┘
       │ 9. JSON Response
       ▼
┌──────────────────────┐
│ Angular Service      │
│ (Observable/Promise) │
└──────┬───────────────┘
       │ 10. Emit Data
       ▼
┌──────────────────────┐
│ Angular Component    │
│ (Update UI)          │
└──────┬───────────────┘
       │ 11. Render Changes
       ▼
┌─────────────┐
│   Browser   │
└─────────────┘

================================================================================
10. KEY FILES REFERENCE
================================================================================

Backend Entry Points:
- server.ts                    → Main server initialization
- app.ts                       → Express app configuration

Database:
- models/index.ts              → Sequelize setup
- models/*.ts                  → Individual model definitions
- data/datacreator.ts          → Database seeding
- data/juiceshop.sqlite        → SQLite database file

API Routes:
- routes/login.ts              → Authentication
- routes/search.ts             → Product search
- routes/basket.ts             → Basket operations
- routes/feedback.ts           → Feedback submission
- routes/*.ts                  → Other API endpoints

Frontend Entry Points:
- frontend/src/main.ts         → Bootstrap Angular
- frontend/src/app/app.module.ts → Root module

Frontend Services:
- frontend/src/app/services/   → HTTP services

Frontend Components:
- frontend/src/app/            → UI components

================================================================================
END OF DOCUMENT
================================================================================
